###########################################################
#
# Machine Learning Framework
#
# For Random Forrests and SVM models only
#
###########################################################
#
# Designed to ensure that data is correctly partioned, and processed 
#
# By B. G. Bland 
#
set.seed(500) # Forces same random number to be produced

# Example Framework code
rm(list=ls())

#Instrument and dates
Instrument <- "TSLA.US"
TrainingStartDate = "20110101"
TrainingEndDate = "20180501"
TestStartDate="20180502"
TestEndDate="20190701"

# Edit these variables to control the columns to fit
ProjectTitle <- "STOOQ Data ML"

ColumnsToSelectForTraining <- c("WPR","FastK","DNTopProx","BuySellHold") # Reduce data set from original
DisplayColumnNames <- ColumnsToSelectForTraining    # Rename the columns

# Prediction variable
PredictionVariable <- "BuySellHold"                                          # y^ the prediction variable
VariableNames <- setdiff(DisplayColumnNames,PredictionVariable)
SamplingMethod <- FALSE

# Data Analysis Options
PrintExamplesinAnalysis <- TRUE
DrawChartsinAnalysis    <- TRUE
DrawChartsOfResults     <- TRUE
DrawImportanceCharts    <- TRUE

# Regression Options
RegressionModel <- "SVM"            # Can be SVM , RF or RFRLT
# Note: Comment out factor lines in DataLoadAndFormat function to get SVM to work
RegressionType  <- "regression"    # Use only regression or classification
NumberOfTrees   <- 15
SplitPercent    <- 80/100

# Load ggplot library if charts are required
if ((DrawChartsinAnalysis == TRUE) || (DrawChartsOfResults == TRUE) || (DrawImportanceCharts == TRUE))
{
  print("Loading GGPLOT2 Library")
  library(ggplot2)
}

#####################################################################################
#
# Functions - Edit the Data Load and Format Function to ingest the data
#
#####################################################################################

GetData <- function(Instrument="",DataPath="C:\\Data",DebugThis=TRUE)
{
  
  library(fst)
  
  # Lets store the Instrument with todays date
  Today = Sys.Date()
  destfile=paste(DataPath,"\\",Instrument,"-",Today,".CSV",sep="")
  
  
  # Do we already have the data
  if (file.exists(destfile)) {
    
    if (DebugThis==TRUE) {print(paste("Found file already exists so loading now ...",destfile))}
    
    InstrumentData <- read.fst(destfile,as.data.table = TRUE)
    
    return(InstrumentData)
    
  } else {
    
    if (DebugThis==TRUE) {print(paste("Loading from Stooq ..."))}
    
    InstrumentData <- read.csv(paste("https://stooq.com/q/d/l/?s=",Instrument,"&i=d",sep=""))
    
    # Create rownames
    rownames(InstrumentData) <- InstrumentData$Date
    InstrumentData$Date <- NULL
    
    # Convert the data format
    InstrumentData <- as.data.frame(InstrumentData)
    InstrumentData$Date <- as.Date(rownames(InstrumentData),"%Y-%m-%d")
    
    # Write file to FST format and then read back  
    if (DebugThis==TRUE) {print(paste("Found data now writing file for next time ...",destfile))}
    write.fst(InstrumentData,destfile)
    
    if (DebugThis==TRUE) {print(paste("Reading file back in now ...",destfile))}
    InstrumentData <- read.fst(destfile,as.data.table = TRUE)
    
    return(InstrumentData)
    
  }
  
}

# Function to load a check data 
DataLoadAndFormat <- function(Backtest=TRUE,Debug=TRUE,
                              TrainingStartDate = "",          # Start of training period
                              TrainingEndDate = "",            # End of training period
                              TestStartDate="",                # Start of testing period
                              TestEndDate="",                  # End of testing period
                              Instrument="")                   # Instrument
{
  if (Debug==TRUE) {print("Loading data")}
  
  
  # Use example MTCARS data set
  DataFrame <- GetData(Instrument,"D:\\DATA",DebugThis=TRUE)
  
  # Build New Data Frame for ML
  DataFrame <- data.frame(Date=DataFrame$Date,
                          Open_Price=DataFrame$Open,
                          High_Price=DataFrame$High,
                          Low_Price=DataFrame$Low,
                          Close_Price=DataFrame$Close,
                          Volume=DataFrame$Volume)
  
  # Select only data required
  DataFrame <- subset(DataFrame,Date > as.Date(TrainingStartDate,"%Y%m%d"))
  DataFrame <- subset(DataFrame,Date < as.Date(TestEndDate,"%Y%m%d"))
  
  # Fit the lines now
  
  #Williams %R
  DataFrame$WPR <- WPR(DataFrame$Close_Price, n = 7)
  
  # Stoch
  Stoch <- stoch(DataFrame$Close_Price, 
                 nFastK = 7, 
                 nFastD = 3, 
                 nSlowD = 3, 
                 bounded = TRUE,
                 smooth = 1)
  
  DataFrame$FastK <- Stoch[,1]
  DataFrame$FastK <- ifelse(DataFrame$FastK < 0,0,DataFrame$FastK)
  
  # DonchianChannel
  DN <- DonchianChannel( DataFrame[,c("High_Price","Low_Price")],n=21 )
  DataFrame$DNHigh <- DN[,1]
  DataFrame$DNMid <- DN[,2]
  DataFrame$DNLow <- DN[,3]
  
  DataFrame$DN_Percent_Range <- (DataFrame$DNHigh - DataFrame$DNLow)
  DataFrame$DN_Top_Prox <- (DataFrame$DNHigh - DataFrame$Close_Price) / DataFrame$DN_Percent_Range
  
  #Create next Close Price
  DataFrame$NextClose <- c(tail(DataFrame$Close_Price,nrow(DataFrame)-1),0)
  DataFrame$PriceReturn <- DataFrame$NextClose - DataFrame$Close_Price
  
  DataFrame$NextClosePlusOne <- c(tail(DataFrame$NextClose,nrow(DataFrame)-1),0)
  DataFrame$PriceReturnPlusOne <- DataFrame$NextClosePlusOne - DataFrame$Close_Price
  
  
  #Now make new data frame
  DataFrame <- data.frame(Date= DataFrame$Date,
                          Close_Price = DataFrame$Close_Price,
                          WPR = DataFrame$WPR,
                          FastK = DataFrame$FastK,
                          DNTopProx = DataFrame$DN_Top_Prox,
                          PriceReturn = DataFrame$PriceReturnPlusOne)
  
  #Set the last price return to zero
  DataFrame$PriceReturn[nrow(DataFrame)] = 0
  DataFrame$PriceReturn[nrow(DataFrame)-1] = 0
  
  # Calculate best buying and selling times
  SlopeChangePeriod <- 10 # Days
  NoRows <- nrow(DataFrame)
  WindowSize1 <- SlopeChangePeriod * 2   # Should be twice the period
  SequenceSteps1 <- round(SlopeChangePeriod/8,0)  # Smaller gives more data points
  
  Frames <- seq(1,NoRows - WindowSize1,by=SequenceSteps1)
  
  # Define new columns
  DataFrame$MaxInWindow <- 0
  DataFrame$MinInWindow <- 0
  
  # Loop around for every frame to pick max and min values
  for (Frame in Frames)
  {
    StartOfFrame <- Frame
    EndOfFrame <- Frame + WindowSize1
    
    Window <- DataFrame[StartOfFrame:EndOfFrame-1,] # Cut the data frame into a small window
    
    MaxInWindow <- which.max(Window$Close_Price)  # Which.Max gives the position of the highest value
    MinInWindow <- which.min(Window$Close_Price)
    
    # Mark the highest and lowest values with a 1
    if (MaxInWindow >1)
    {
      DataFrame[MaxInWindow + StartOfFrame - 2,]$MaxInWindow <- 1
    } else {
      DataFrame[MaxInWindow + StartOfFrame - 1,]$MaxInWindow <- 1
    }
    if (MinInWindow > 1)
    {
      DataFrame[MinInWindow + StartOfFrame - 2,]$MinInWindow <- 1
    } else {
      DataFrame[MinInWindow + StartOfFrame - 1,]$MinInWindow <- 1
    }
  }
  
  DataFrame$BuySellHold <- ifelse(DataFrame$MaxInWindow == 1,-1,
                                  ifelse(DataFrame$MinInWindow == 1,1,0))
  
  DataFrame <- na.omit(DataFrame)
  
  return(DataFrame)
  
}


## Quick summary of data we are using to compute the column type and number of levels
DataAnalysis <- function(DataFrame,PredictionVariable="",Title = "",PrintExamples = TRUE,DrawCharts = TRUE)
{
  
  print("Data Analysis of DataFrame")
  print("")
  
  if (is.data.frame(DataFrame) == TRUE)
  {
    
    Cols <- colnames(DataFrame)
    
    for (col in Cols)
    {
      
      # Select the column number
      ColNo <- which(Cols == col)
      print(paste("Column",col))
      print(paste("    No unique values =",length(unique(DataFrame[,ColNo]))))
      print(paste("    Class",class(DataFrame[,ColNo]),"with",length(levels(DataFrame[,ColNo])),"levels"))
      
      # Print top five unique items
      if (PrintExamples == TRUE)
      {
        # Now print the top 5 unique values in the column
        for (i in head(unique(DataFrame[,ColNo]),5)){print(paste("        ",col,"=",i))}
      }
      # Now print summary if not a factor
      if (class(DataFrame[,ColNo])!= "factor") {
        print(paste("    Min",min(DataFrame[,ColNo]),
                    "Median",median(DataFrame[,ColNo]),
                    "Mean",mean(DataFrame[,ColNo]),
                    "Max",max(DataFrame[,ColNo])))
      }
      
      print(" ")
      
      if (DrawCharts == TRUE)
      {
        if (col != PredictionVariable)
        {
          # Now plot the results
          Prediction <- which(Cols == PredictionVariable)
          PredictionCol <- DataFrame[,Prediction]
          ActualCol <- DataFrame[,ColNo]
          PlotDF <- data.frame(Prediction = PredictionCol, Actual = ActualCol)
          
          ResultsPlot <- ggplot(PlotDF,aes(x=Actual,y=Prediction)) +
            geom_point(aes(x=Actual,y=Prediction),
                       colour="Blue",
                       fill="DarkBlue",
                       size=0.5) +
            geom_smooth(method="lm") +
            ylab(paste(PredictionVariable,"- Predict Column")) +
            xlab(paste(col,"- Example Column")) +
            theme(plot.title = element_text(size = 12),
                  axis.title.x = element_text(size = 10),
                  axis.title.y = element_text(size = 10),
                  text = element_text(size = 8)) +
            ggtitle(paste(Title,"-",PredictionVariable,"versus",col))
          print(ResultsPlot)
        }
      }
    }
  }
}

# Split function
SplitData <- function(DataFrame,PercentToSplit,SplitUsingSampleMethod=TRUE)
{
  # Will add index column
  DataFrame$x <- seq(1,nrow(DataFrame))
  
  ## Number of rows to sample
  smp_size <- floor(PercentToSplit * nrow(DataFrame))
  
  print(paste("Using training sample size of",smp_size,"using",PercentToSplit,"% split"))
  print(paste("From total data set of",nrow(DataFrame),"rows"))
  
  if (SplitUsingSampleMethod == TRUE)
  {
    
    print("Using sampling method to select training data")
    
    # Create sampling index
    train_ind <- sample(DataFrame$x, size = smp_size)
    
    # Now split te data into training and test
    train <- DataFrame[train_ind, ]
    test <- DataFrame[-train_ind, ]
    
  } else {
    
    print("Using first n% to select training data")
    
    # Use the first percentage and test with the remaining
    train <- DataFrame[1:smp_size,]
    test <- DataFrame[(smp_size+1):nrow(DataFrame),]
    
  }
  
  # Check nrows of both
  print(paste("Number of rows in training set ... ",nrow(train)))
  print(paste("Number of rows in testing set ... ",nrow(test)))
  
  
  # Now remove the x variable
  train$x <- NULL
  test$x <- NULL
  
  # Return list of data frames
  ReturnList <- list(train,test)
  
  return(ReturnList)
}

# Function to pre-process the data
PreProcess <- function(DataFrame,Columns,ColumnNames,Backtest=TRUE,Debug=TRUE,PercentageToSplit=0,UseSampleMethod=TRUE)
{
  if (Debug==TRUE) {print("PreProcessing data")}
  
  # Generic code
  DataFrame <- DataFrame[,Columns]
  colnames(DataFrame) <- ColumnNames
  
  # Split data
  ListOfDataFrames <- SplitData(DataFrame,PercentToSplit=PercentageToSplit,SplitUsingSampleMethod=UseSampleMethod)
  
  return(ListOfDataFrames)
}

TrainingModelRF <- function(DataFrame,ColumnNames,PredictVariable="S",NTrees=5,
                            Backtest=TRUE,Debug=TRUE,SaveModel=FALSE,PlotImportance=TRUE)
{
  if (Debug==TRUE) {print("Training on data using RF Model")}
  
  library(randomForest)
  
  PredictVariable <- DataFrame[,PredictVariable]
  
  VariableColumns <- DataFrame[,ColumnNames]
  
  DataFrame <- cbind(VariableColumns,PredictVariable)
  
  #Print the fitting parameters
  if (Debug==TRUE) {print(paste("    Number of trees = ",NTrees))}
  
  # Train
  Model = randomForest(PredictVariable ~ . ,
                       data = DataFrame,
                       keep.forest=TRUE,
                       importance=TRUE,
                       ntree = NTrees)
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, "RandomForest.rds")
    if (Debug==TRUE) {print(paste("    Saving to RandomForest.rds"))}
  }
  
  # Plot importance
  if (PlotImportance == TRUE) {ImportancePlot(Model,"Example Importance Plot","Random Forest Model")}
  
  return(Model)
  
}

PredictRF <- function(DataFrame,ColumnNames,Model,
                      Backtest=TRUE,Debug=TRUE,LoadModel=FALSE)
{
  if (Debug==TRUE) {print("Predicting from model and data using RF Model")}
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS("RandomForest.rds")
    if (Debug==TRUE) {print(paste("    Loaded from RandomForest.rds"))}
  }
  
  VariableColumns <- DataFrame[,ColumnNames]
  
  DataFrame$Prediction <- predict(Model,VariableColumns)
  
  return(DataFrame)
}

TrainingModelRFRLT <- function(DataFrame,ColumnNames,PredictVariable="",NTrees=10,
                               Backtest=TRUE,Debug=TRUE,SaveModel=FALSE,PlotImportance=TRUE,RegType="")
{
  if (Debug==TRUE) {print("Training on data using RFRLT model")}
  
  library(RLT)
  
  # Select Cols required
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,ColumnNames]
  
  # Run model
  Model = RLT(VariableColumns, PredictVariable,
              model = RegType, #  regression, classification or survival 
              use.cores = 7,
              ntrees = NTrees,
              importance = TRUE, 
              reinforcement = TRUE,
              combsplit = 20,
              embed.ntrees = NTrees)
  
  # Save model if required
  if (SaveModel == TRUE) {saveRDS(Model, "RandomForestRLT.rds")}
  
  # Plot importance
  if (PlotImportance == TRUE) {barplot(Model$VarImp)}
  
  return(Model)
  
}

PredictRFRLT <- function(DataFrame,ColumnNames,Model,
                         Backtest=TRUE,Debug=TRUE)
{
  if (Debug==TRUE) {print("Predicting from RF RLT model and data")}
  
  VariableColumns <- DataFrame[,ColumnNames]
  
  PredictionList <- predict(Model,VariableColumns)
  
  DataFrame$Prediction <- PredictionList[[2]]   # Select only the predictions
  
  return(DataFrame)
  
}

TrainingModelSVM <- function(DataFrame,ColumnNames,PredictVariable="",NTrees=10,
                             Backtest=TRUE,Debug=TRUE,SaveModel=FALSE,PlotImportance=TRUE)
{
  if (Debug==TRUE) {print("Training on data using Support Vector Machine")}
  
  library(e1071)
  
  # Select Cols required
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,ColumnNames]
  
  Model <- svm(VariableColumns, PredictVariable)
  
  if (PlotImportance==TRUE)
  {
    print(summary(Model))
  }
  
  return(Model)
  
}

PredictSVM <- function(DataFrame,ColumnNames,Model,
                       Backtest=TRUE,Debug=TRUE)
{
  if (Debug==TRUE) {print("Predicting from data using Support Vector Machine model")}
  
  VariableColumns <- DataFrame[,ColumnNames]
  
  PredictionList <- predict(Model,VariableColumns)
  
  DataFrame$Prediction <- PredictionList   
  
  return(DataFrame)
  
}

# Handles the testing of the accuracy of fit extra
PostProcess <- function(DataFrame,PredictVariable="",Backtest=TRUE,Debug=TRUE,TestingSet=FALSE,RegressionModel="",Variable="",RegType="",DrawCharts = FALSE)
{
  
  if (TestingSet == FALSE)
  {
    Item <- "Training Set"
    Title = paste("Training Data with",RegressionModel,"model predicting",Variable)
    if (Debug==TRUE) {print(paste("Post processing training data after running",RegressionModel,"model predicting",Variable))}
  } else {
    Item <- "Test Set"
    Title = paste("Testing Data with",RegressionModel,"model predicting",Variable)
    if (Debug==TRUE) {print(paste("Post processing testing data after running",RegressionModel,"model predicting",Variable))}
  }
  
  PredictVariable1 <- DataFrame[,PredictVariable]
  DataFrame$Actual <- PredictVariable1
  
  # Handle x y type regression results
  if (RegType =="regression")
  {
    # reformat data
    DataFrame$Error <- DataFrame$Prediction - DataFrame$Actual
    
    # Calculate the RMSE and return it as part of the function
    RMSE <- sqrt(sum(DataFrame$Error^2))
    ReturnDataFrame <- data.frame(Desc=paste(Item,"RMS Error"),RMSE=RMSE)
    print(ReturnDataFrame)
    
    if (DrawCharts == TRUE)
    {
      # Now plot the results
      ResultsPlot <- ggplot(DataFrame,aes(x=Actual,y=Prediction)) +
        geom_point(aes(x=Actual,y=Prediction),
                   colour="Blue",
                   fill="DarkBlue") +
        geom_smooth(method="lm") +
        xlab("Actual Value") +
        ylab("Prediction") +
        theme(plot.title = element_text(size = 12),
              axis.title.x = element_text(size = 10),
              axis.title.y = element_text(size = 10),
              text = element_text(size = 8)) +
        ggtitle(paste("Actual versus Predicted - ",Title))
      print(ResultsPlot)
    }
  }
  
  # Handle classification problems
  if (RegType =="classification")
  {
    # Work out if not equal
    DataFrame$Error <- ifelse(DataFrame$Prediction == PredictVariable, 1, 0)
    print(DataFrame)
    
    # find errors
    ErrorsFrame <- subset(DataFrame,DataFrame$Prediction != DataFrame$Actual)
    print(paste("Number of rows predicted",nrow(DataFrame)))
    print(paste("Number of errors found",nrow(ErrorsFrame)))
    
    ReturnDataFrame <- ErrorsFrame
    
  }
  
  return(ReturnDataFrame)
}

ImportancePlot <- function(Model,Title="",SubTitle="",Caption="")
{
  
  library(ggplot2)
  
  MeanDecreaseGini <- importance(Model)
  MeanDecreaseGini <- as.data.frame(MeanDecreaseGini)
  MeanDecreaseGini$Variable <- rownames(MeanDecreaseGini)
  
  ImpPlot <- ggplot(data = MeanDecreaseGini, aes(Variable, IncNodePurity)) +
    geom_bar(stat = "identity", position = "dodge",colour="red",alpha=0.8,fill="red") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    labs(caption = Caption) +
    ggtitle(Title,
            subtitle = paste(SubTitle)) 
  print(ImpPlot)
}


###############################################################################
#
#   Main code
#
###############################################################################

# Load data
DataFrame <- DataLoadAndFormat(Backtest=FALSE,Debug=TRUE,
                               TrainingStartDate = TrainingStartDate,TrainingEndDate = TrainingEndDate,
                               TestStartDate=TestStartDate,TestEndDate=TestEndDate,
                               Instrument = Instrument)


if (nrow(DataFrame)>0) 
{
  # Pre-Process
  ListOfDataFrames <- PreProcess(DataFrame,ColumnsToSelectForTraining,
                                 DisplayColumnNames,
                                 Backtest=TRUE,
                                 Debug=TRUE,SplitPercent,UseSampleMethod=SamplingMethod)
  
  # Check data formats after pre-processing
  DataAnalysis(ListOfDataFrames[[1]],
               PredictionVariable,
               ProjectTitle,
               PrintExamples = PrintExamplesinAnalysis,
               DrawCharts = DrawChartsinAnalysis)
  
  if (RegressionModel == "SVM")
  {
    print("Training with Support Vector Machine")
    
    # Training
    Model <-     TrainingModelSVM(ListOfDataFrames[[1]],
                                  VariableNames,
                                  PredictVariable=PredictionVariable,
                                  NTrees=NumberOfTrees,
                                  SaveModel=FALSE,
                                  PlotImportance=DrawImportanceCharts)
    
    # Predict from training
    TrainingPredictions <- PredictSVM(ListOfDataFrames[[1]],
                                      VariableNames,
                                      Model,
                                      Backtest=TRUE,
                                      Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TrainingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=FALSE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType,DrawCharts = DrawChartsOfResults)
    
    
    # Predict testing set
    TestingPredictions <- PredictSVM(ListOfDataFrames[[2]],VariableNames,
                                     Model,
                                     Backtest=TRUE,
                                     Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TestingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=TRUE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType,DrawCharts = DrawChartsOfResults)
    
  }
  
  if (RegressionModel == "RF")
  {
    
    print("Training with Random Forrest - Original version")
    
    # Training
    Model <-     TrainingModelRF(ListOfDataFrames[[1]],
                                 VariableNames,
                                 PredictVariable=PredictionVariable,
                                 NTrees=NumberOfTrees,
                                 SaveModel=TRUE,
                                 PlotImportance=DrawImportanceCharts)
    
    # Predict from training
    TrainingPredictions <- PredictRF(ListOfDataFrames[[1]],
                                     VariableNames,
                                     Model,
                                     Backtest=TRUE,
                                     Debug=TRUE,
                                     LoadModel=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TrainingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=FALSE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType,DrawCharts = DrawChartsOfResults)
    
    # Predict testing set
    TestingPredictions <- PredictRF(ListOfDataFrames[[2]],VariableNames,
                                    Model,
                                    Backtest=TRUE,
                                    Debug=TRUE,
                                    LoadModel=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TestingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=TRUE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType,DrawCharts = DrawChartsOfResults)
    
  }
  
  if (RegressionModel == "RFRLT")
  {
    print("Training with Random Forrest - RLT version")
    
    # Training
    Model <-     TrainingModelRFRLT(ListOfDataFrames[[1]],
                                    VariableNames,
                                    PredictVariable=PredictionVariable,
                                    NTrees=NumberOfTrees,
                                    SaveModel=FALSE,
                                    PlotImportance=DrawImportanceCharts,RegType=RegressionType)
    
    # Predict from training
    TrainingPredictions <- PredictRFRLT(ListOfDataFrames[[1]],
                                        VariableNames,
                                        Model,
                                        Backtest=TRUE,
                                        Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TrainingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=FALSE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType,DrawCharts = DrawChartsOfResults)
    
    # Predict testing set
    TestingPredictions <- PredictRFRLT(ListOfDataFrames[[2]],VariableNames,
                                       Model,
                                       Backtest=TRUE,
                                       Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TestingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=TRUE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType,DrawCharts = DrawChartsOfResults)
    
  }
  
} else {
  print("No data found")
}

FinalDataFrame <- rbind(TrainingPredictions,TestingPredictions)
FinalDataFrame$Date <- DataFrame$Date
FinalDataFrame$Close_Price <- DataFrame$Close_Price
FinalDataFrame$Buy <- ifelse(FinalDataFrame$BuySellHold == 1,1,NA)
FinalDataFrame$Sell <- ifelse(FinalDataFrame$BuySellHold == -1,1,NA)

FinalDataFrame$BuyPrediction <- ifelse(FinalDataFrame$Prediction > 0.1,1,NA)
FinalDataFrame$SellPrediction <- ifelse(FinalDataFrame$Prediction < -0.1,1,NA)

FinalDataFrame <- subset(FinalDataFrame,Date > as.Date(TestStartDate,"%Y%m%d"))

MeanBuy <- mean(FinalDataFrame$Close_Price * FinalDataFrame$Buy,na.rm = TRUE)
MeanSell <- mean(FinalDataFrame$Close_Price * FinalDataFrame$Sell,na.rm = TRUE)

MeanBuyPrediction <- mean(FinalDataFrame$Close_Price * FinalDataFrame$BuyPrediction,na.rm = TRUE)
MeanSellPrediction <- mean(FinalDataFrame$Close_Price * FinalDataFrame$SellPrediction,na.rm = TRUE)

BasicPlot <- ggplot(FinalDataFrame, aes(Date, Close_Price)) +
  geom_step(col="Darkgreen",aes(y=Close_Price)) +
#  geom_point(col="Darkblue",aes(y=Close_Price*Buy),size=1,alpha=0.4) +
#  geom_point(col="Darkred",aes(y=Close_Price*Sell),size=1,alpha=0.4) +
  geom_point(col="blue",aes(y=Close_Price*BuyPrediction),size=3,alpha=0.4) +
  geom_point(col="red",aes(y=Close_Price*SellPrediction),size=3,alpha=0.4) +
  geom_hline(col="Darkblue",yintercept=MeanBuy,size=2,alpha=0.4) +
  geom_hline(col="Darkred",yintercept=MeanSell,size=2,alpha=0.4) +
  geom_hline(col="lightblue",yintercept=MeanBuyPrediction,size=2,alpha=0.4) +
  geom_hline(col="orange",yintercept=MeanSellPrediction,size=2,alpha=0.4) +
  theme(legend.position = "top") +
  labs(
    x = "Date",
    y = "Price",
    subtitle = paste("Buy and Sell Points - for training only - ",Instrument,"(created on",Sys.Date(),")"))
print(BasicPlot)

