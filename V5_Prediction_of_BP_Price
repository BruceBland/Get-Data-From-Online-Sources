###########################################################
#
# Machine Learning Framework V5.0
#
# Multi models now supported
#
###########################################################
#
# Designed to ensure that data is correctly partioned, and processed 
#
# By B. G. Bland 
#
set.seed(60) # Forces same random number to be produced

# Example Framework code
rm(list=ls())

# Add libraries required here ...


# Add data loading parameters here ...
SetDataLoadParameters <- function()
{
  
  # Add all the additional parameters needed to load data here (eg Instrument) ...
  DataLoadParameters = list()
  
  #Instrument and dates
  DataLoadParameters$Instrument <- "IBM.US"
  DataLoadParameters$TrainingStartDate = "19800101"
  DataLoadParameters$TrainingEndDate   = "20170901"
  DataLoadParameters$TestStartDate     = "20170902"
  DataLoadParameters$TestEndDate       = "20190701"
  DataLoadParameters$TradingTimeFrameInDays <- 80  # Days
  DataLoadParameters$StepSize  <- 80  # Days
  DataLoadParameters$RSI_n     <- 52
  DataLoadParameters$WPR_n     <- 14
  DataLoadParameters$TOPPROX_n <- 14
  DataLoadParameters$FASTK_n   <- 14
  DataLoadParameters$SDMultiplier <- 1.25  # n times SD
  
  # Selection Threshols
  #DataLoadParameters$SelectionThreshold <- 0.025
  
  return(DataLoadParameters)
}

# Function to ensure no global variables are used within the Machine Learning Functions
#
# Define your own parameters here
#
SetParameters <- function()
{
  
  # This example uses the mtcars dataset which is provided in base R.
  # Use the following fields to change the behaviour
  
  #[, 1]	mpg	  -   Miles/(US) gallon
  #[, 2]	cyl	  -   Number of cylinders
  #[, 3]	disp	-   Displacement (cu.in.)
  #[, 4]	hp	  -   Gross horsepower
  #[, 5]	drat	-   Rear axle ratio
  #[, 6]	wt	  -   Weight (1000 lbs)
  #[, 7]	qsec	-   1/4 mile time
  #[, 8]	vs	  -   Engine (0 = V-shaped, 1 = straight)
  #[, 9]	am	  -   Transmission (0 = automatic, 1 = manual)
  #[,10]	gear	-   Number of forward gears
  #[,11]	carb	-   Number of carburetors
  
  # ML Params
  MLParameterList = list()
  
  MLParameterList$ProjectTitle = "Instrument Analysis"
  MLParameterList$ColumnsToSelectForTraining <- c("WPR","RSI","FastK","DNTopProx","BuySellHold") # Reduce data set from original
  MLParameterList$DisplayColumnNames <-  MLParameterList$ColumnsToSelectForTraining    # Rename the columns
  
  MLParameterList$ConvertToFactors <- FALSE           # Must be false for SVM
  
  # Data Pre processing option
  MLParameterList$OneHotEncodeFactors <- TRUE         # Use for neural networks
  
  MLParameterList$Rescale  <- TRUE                     # Rescale all the values (must be one hot encoded)
  MLParameterList$Maximums <- c(1,100,1, 1.1, 1)        # Max values for each variable
  MLParameterList$Minimums <- c(0,0,  0,-1.1,-1)        # Min value for each variable
  
  # Prediction variable
  MLParameterList$PredictionVariable <- "BuySellHold"                                          # y^ the prediction variable
  MLParameterList$VariableNames <- setdiff(MLParameterList$DisplayColumnNames,MLParameterList$PredictionVariable)
  
  # Sampling method
  MLParameterList$SamplingMethod            <- FALSE
  MLParameterList$SaveModelToFile           <- TRUE
  MLParameterList$FileNameOfModel           <- "ML_Model"
  
  # Regression Options
  MLParameterList$RegressionModel           <- "KNN"           # Can be SVM, RF, RFRLT, NN, KNN, XGB, DEEPNET
  MLParameterList$SplitPercent              <- 90/100
  
  # RF Parameters
  MLParameterList$RegressionType            <- "regression"    # Use only regression or classification
  MLParameterList$NumberOfTrees             <- 100             # Decision tree models only
  
  # NeuralNet parameters
  MLParameterList$HiddenLayersStructure     <- c(50)           # Layers required for NN only (Nodes only for this model)
  MLParameterList$Iterations                <- 500             # Number of iterations
  
  # KNN parameters
  MLParameterList$K                         <- 100              # KNN only
  
  # Deepnet parameters
  MLParameterList$activationfun             <- "sigm"          #  activation function of hidden unit.Can be "sigm", or "tanh".Default is "sigm" for logistic function 
  MLParameterList$learningrate              <- 0.9
  MLParameterList$momentum                  <- 0.5             # momentum for gradient descent. Default is 0.5
  MLParameterList$learningrate_scale        <- 1               # learning rate for gradient descent. Default is 0.8. 
  MLParameterList$output                    <- "sigm"
  MLParameterList$numepochs                 <- 100              # increase to add accuracy
  MLParameterList$batchsize                 <- 100             # size of mini-batch. Default is 100.
  MLParameterList$hidden_dropout            <- 0               #  drop out fraction for hidden layer. Default is 0. 
  MLParameterList$visible_dropout           <- 0
  
  # Load parameters
  MLParameterList$BackTest                  <- FALSE
  MLParameterList$Debug                     <- TRUE
  
  # Data Analysis Options
  MLParameterList$PrintExamplesinAnalysis   <- FALSE
  MLParameterList$DrawChartsinAnalysis      <- FALSE
  MLParameterList$DrawChartsOfResults       <- TRUE
  MLParameterList$DrawImportanceCharts      <- FALSE
  
  # Load ggplot library if charts are required
  if ((MLParameterList$DrawChartsinAnalysis == TRUE) || (MLParameterList$DrawChartsOfResults == TRUE) || (MLParameterList$DrawImportanceCharts == TRUE))
  {
    print("Loading GGPLOT2 Library")
    library(ggplot2)
  }
  
  return(MLParameterList)
  
}

#GetData <- function(Instrument="",DataPath="D:\\Data",DebugThis=TRUE)
#{
#  
#  library(fst)
#  
#  # Lets store the Instrument with todays date
#  Today = Sys.Date()
#  destfile=paste(DataPath,"\\",Instrument,"-",Today,".CSV",sep="")
#  
#  # Do we already have the data
#  if (file.exists(destfile)) {
#    
#    if (DebugThis==TRUE) {print(paste("Found file already exists so loading now ...",destfile))}
#    
#    InstrumentData <- tryCatch(
#      
#      read.fst(destfile,as.data.table = TRUE)
#      
#      , error = function(cond)
#      {
#        print("Error")
#        return(NULL)
#      }
#    )
#    
#    InstrumentData$Date <- as.Date(as.character(InstrumentData$Date),"%Y-%m-%d")
#    
#    if (DebugThis==TRUE) {print(paste("Finished loading ...",destfile))}
#    
#    return(InstrumentData)
#    
#  } else {
#    
#    if (DebugThis==TRUE) {print(paste("Loading from Fidessa RAID ResearchDB ..."))}
#    
#    StartDate <- "20010101"
#    EndDate <- "20200101"
#    RequestString <- paste("http://uklon-hft002:8081/ResearchDb/DailyHistorical?fim=",Instrument,
#                           "&start=",StartDate,
#                           "&end=",EndDate,sep="")
#    InstrumentData <- tryCatch(read.csv(RequestString),error = function(cond){return(NULL)})
#    
#    if (is.null(InstrumentData) == FALSE)
#    {
#      if (nrow(InstrumentData) > 0)
#      {
#        # Format into date format
#        InstrumentData$Date <- as.Date(as.character(InstrumentData$Date),"%Y%m%d")
#        
#        # Write file to FST format and then read back  
#        if (DebugThis==TRUE) {print(paste("Found data now writing file for next time ...",destfile))}
#        write.fst(InstrumentData,destfile)
#        
#        if (DebugThis==TRUE) {print(paste("Reading file back in now ...",destfile))}
#        
#        InstrumentData <- tryCatch(
#          
#          read.fst(destfile,as.data.table = TRUE)
#          
#          , error = function(cond)
#          {
#            print("Error")
#            return(NULL)
#          }
#        )
#      } else {
#        InstrumentData <- NULL
#      }
#    }
#    
#    return(InstrumentData)
#    
#  }
#  
#}


####################################################################################
#
# Get Data function to load dat from Stooq
#
#####################################################################################
GetData <- function(Instrument="",DataPath="D:\\Data",DebugThis=TRUE,Historic=TRUE)
{
  
  library(fst)
  
  if (Historic == TRUE)
  {
    
    # Lets store the Instrument with todays date
    Today = Sys.Date()
    destfile=paste(DataPath,"\\",Instrument,"-",Today,".CSV",sep="")
    
    
    # Do we already have the data
    if (file.exists(destfile)) {
      
      if (DebugThis==TRUE) {print(paste("Found file already exists so loading now ...",destfile))}
      
      InstrumentData <- read.fst(destfile,as.data.table = TRUE)
      
      return(InstrumentData)
      
    } else {
      
      if (DebugThis==TRUE) {print(paste("Loading from Stooq ..."))}
      
      InstrumentData <- read.csv(paste("https://stooq.com/q/d/l/?s=",Instrument,"&i=d",sep=""))
      
      if (nrow(InstrumentData) > 0)
      {
        # Create rownames
        rownames(InstrumentData) <- InstrumentData$Date
        InstrumentData$Date <- NULL
        
        # Convert the data format
        InstrumentData <- as.data.frame(InstrumentData)
        InstrumentData$Date <- as.Date(rownames(InstrumentData),"%Y-%m-%d")
        
        # Write file to FST format and then read back  
        if (DebugThis==TRUE) {print(paste("Found data now writing file for next time ...",destfile))}
        write.fst(InstrumentData,destfile)
        
        if (DebugThis==TRUE) {print(paste("Reading file back in now ...",destfile))}
        InstrumentData <- read.fst(destfile,as.data.table = TRUE)
      } else {
        InstrumentData <- NULL
      }
      
      return(InstrumentData)
    }
    
  } else {
    
    
    if (DebugThis==TRUE) {print(paste("Loading LIVE DATA from Stooq ..."))}
    
    InstrumentData <- read.csv(paste("https://stooq.com/q/l/?s=",Instrument,"&f=sd2t2ohlcv&h&e=csv",sep=""))
    
    if (nrow(InstrumentData) > 0)
    {
      # Create rownames
      rownames(InstrumentData) <- InstrumentData$Date
      InstrumentData$Date <- NULL
      
      # Convert the data format
      InstrumentData <- as.data.frame(InstrumentData)
      InstrumentData$Date <- as.Date(rownames(InstrumentData),"%Y-%m-%d")
      
      if (DebugThis==TRUE) {print(paste("Found LIVE data",nrow(InstrumentData),"rows returned"))}
      
      InstrumentData <- as.data.frame(InstrumentData)
      
    } else {
      InstrumentData <- NULL
    }
    
    return(InstrumentData)
  }
  
}

####################################################################################
#
# Get historical and live data from Stooq
#
#####################################################################################
GetHistoricAndLiveData <- function(Instrument="",DataPath="D:\\Data",DebugThis=TRUE)
{
  ConvertToSeconds <- function(X)
  {
    X <- strsplit(X, ":")
    sapply(X, function(Y) sum(as.numeric(Y) * c(3600, 60, 1)))
  }
  
  # Get historical and live data
  HistoricExampleData <- GetData(Instrument,DataPath=DataPath,DebugThis=DebugThis,Historic=TRUE)
  
  library(lubridate)
  Weekday = wday(Sys.Date(), label = TRUE)
  NowInSecs <- ConvertToSeconds(format(Sys.time(),"%X"))
  USOpenInSecs <- ConvertToSeconds("16:30:00")
  
  # Only add todays data if the markets are open
  if (length(grep(".US",Instrument))==0 || (NowInSecs > USOpenInSecs))
  {
    if (Weekday != "Sat" && Weekday != "Sun")
    {
      LiveExampleData <- GetData(Instrument,DataPath=DataPath,DebugThis=DebugThis,Historic=FALSE)
      
      # Add the columns that are missing from the historical one
      HistoricExampleData$Symbol <- LiveExampleData$Symbol[1]
      HistoricExampleData$Time <- "01:00:00"
      HistoricExampleData$OpenInt <- NULL
      LiveExampleData$Volume <- NULL
      HistoricExampleData$Volume <- NULL
      
      # Add the data together
      HistoricExampleData <- rbind(HistoricExampleData,LiveExampleData)
    }
  }
  return(HistoricExampleData)
}

#ExampleData <- GetHistoricAndLiveData("LLOY.UK",DataPath="D:\\Data",DebugThis=TRUE)


#####################################################################################
#
# Functions - Edit the Data Load and Format Function to ingest the data
#
#####################################################################################

# Function to load a check data 
DataLoadAndFormat <- function(Backtest=TRUE,Debug=TRUE,ConvertToFactors=FALSE,DataLoadParameters="")
{
  if (Debug==TRUE) {print("Loading data")}
  
  library(TTR)
  library(fst)
  library(data.table)
  
  # Use example 
  DataFrame <- GetHistoricAndLiveData(DataLoadParameters$Instrument,"D:\\DATA",DebugThis=TRUE)
  
  if (is.null(DataFrame) == FALSE)
  {
    # Build New Data Frame for ML
    DataFrame <- data.frame(Date=DataFrame$Date,
                            Open_Price=DataFrame$Open,
                            High_Price=DataFrame$High,
                            Low_Price=DataFrame$Low,
                            Close_Price=DataFrame$Close)
    
    # Select only data required
    DataFrame <- subset(DataFrame,Date > as.Date(DataLoadParameters$TrainingStartDate,"%Y%m%d"))
    DataFrame <- subset(DataFrame,Date < as.Date(DataLoadParameters$TestEndDate,"%Y%m%d"))
    
    # Fit the lines now
    if (nrow(DataFrame) > 1)
    {
      
      
      #Williams %R
      DataFrame$WPR <- WPR(DataFrame$Close_Price, n = DataLoadParameters$WPR_n)
      
      #RSI
      RSIFit <- tryCatch(
        
        RSI(DataFrame$Close_Price, n = DataLoadParameters$RSI_n)
        
        , error = function(cond){
          print("Cannot fit RSI")
          return(NULL)
        }
      )
      
      if (is.null(RSIFit)==TRUE) {return(NA)}
      
      DataFrame$RSI <- RSIFit
      
      Stoch <- tryCatch(
        
        # Stoch
        stoch(DataFrame$Close_Price, 
              nFastK = DataLoadParameters$FASTK_n, 
              nFastD = 3, 
              nSlowD = 3, 
              bounded = TRUE,
              smooth = 1)
        
        ,error=function(cond)
        {
          print("Cannot fit WPR,RSI and Stock indicators")
          return(NULL)
        }
      )
      
      if (is.null(Stoch)==TRUE) {return(NA)}
      
      DataFrame$FastK <- Stoch[,1]
      DataFrame$FastK <- ifelse(DataFrame$FastK < 0,0,DataFrame$FastK)
      
      # DonchianChannel
      DN <- DonchianChannel( DataFrame[,c("High_Price","Low_Price")],n=DataLoadParameters$TOPPROX_n )
      DataFrame$DNHigh <- DN[,1]
      DataFrame$DNMid <- DN[,2]
      DataFrame$DNLow <- DN[,3]
      
      DataFrame$DN_Percent_Range <- (DataFrame$DNHigh - DataFrame$DNLow)
      DataFrame$DN_Top_Prox <- (DataFrame$DNHigh - DataFrame$Close_Price) / DataFrame$DN_Percent_Range
      
      #Create next Close Price
      DataFrame$NextClose <- c(tail(DataFrame$Close_Price,nrow(DataFrame)-1),0)
      DataFrame$PriceReturn <- DataFrame$NextClose - DataFrame$Close_Price
      
      DataFrame$NextClosePlusOne <- c(tail(DataFrame$NextClose,nrow(DataFrame)-1),0)
      DataFrame$PriceReturnPlusOne <- DataFrame$NextClosePlusOne - DataFrame$Close_Price
      
      
      #Now make new data frame
      DataFrame <- data.frame(Date= DataFrame$Date,
                              Close_Price = DataFrame$Close_Price,
                              WPR = DataFrame$WPR,
                              RSI = DataFrame$RSI,
                              FastK = DataFrame$FastK,
                              DNTopProx = DataFrame$DN_Top_Prox,
                              PriceReturn = DataFrame$PriceReturnPlusOne)
      
      #Set the last price return to zero
      DataFrame$PriceReturn[nrow(DataFrame)] = 0
      DataFrame$PriceReturn[nrow(DataFrame)-1] = 0
      
      # Define new columns
      NoRows <- nrow(DataFrame)
      DataFrame$MaxInWindow <- 0
      DataFrame$MinInWindow <- 0
      
      
      # Find good buying and selling points
      WindowSize1 <- DataLoadParameters$TradingTimeFrameInDays   # Should be twice the period
      SequenceSteps1 <- DataLoadParameters$StepSize  # Smaller gives more data points
      
      Frames <- seq(1,NoRows - WindowSize1,by=SequenceSteps1)
      
      # Loop around for every frame to pick max and min values
      for (Frame in Frames)
      {
        StartOfFrame <- Frame
        EndOfFrame <- Frame + WindowSize1
        
        Window <- DataFrame[StartOfFrame:EndOfFrame-1,] # Cut the data frame into a small window
        
        MaxInWindow <- which.max(Window$Close_Price)  # Which.Max gives the position of the highest value
        MinInWindow <- which.min(Window$Close_Price)
        
        # Mark the highest and lowest values with a 1
        if (MaxInWindow > 1)
        {
          DataFrame[MaxInWindow + StartOfFrame - 2,]$MaxInWindow <-  1 
        }
        if (MinInWindow > 1)
        {
          DataFrame[MinInWindow + StartOfFrame - 2,]$MinInWindow <-  1
        }
      }
      
      
      print(paste("Sum of max values",sum(DataFrame$MaxInWindow)))
      print(paste("Sum of min values",sum(DataFrame$MinInWindow)))
      
      DataFrame$BuySellHold <- ifelse(DataFrame$MaxInWindow == 1,-1,
                                      ifelse(DataFrame$MinInWindow == 1,1,0))
      
      
      DataFrame <- na.omit(DataFrame)
      
      # Now check data is ok
      if(is.infinite(min(DataFrame$DNTopProx)) == TRUE)
      {
        DataFrame <- NA
      }
      
      
    } else {
      DataFrame <- NA
    }
  } else {
    DataFrame <- NA
  }
  return(DataFrame)
  
}

ProcessPredictions <- function(TrainingPredictions,TestingPredictions,DataFrame,DataLoadParameters)
{
  
  
  #TrainingHistPlot <- ggplot(TrainingPredictions, aes(Prediction)) +
  #  geom_histogram(bins=50,fill="blue") +
  #  theme(legend.position = "top") +
  #  labs(
  #    x = "Prediction",
  #    y = "Count",
  #    title = paste("Training Predictions",DataLoadParameters$Instrument),
  #    subtitle = paste("Trading Window = ",DataLoadParameters$TradingTimeFrameInDays))
  #print(TrainingHistPlot)
  
  #TestingHistPlot <- ggplot(TestingPredictions, aes(Prediction)) +
  #  geom_histogram(bins=50,fill="blue") +
  #  theme(legend.position = "top") +
  #  labs(
  #    x = "Prediction",
  #    y = "Count",
  #    title = paste("Testing Predictions",DataLoadParameters$Instrument),
  #    subtitle = paste("Trading Window = ",DataLoadParameters$TradingTimeFrameInDays))
  #print(TestingHistPlot)
  
  
  
  # Build the final data frame to show the results
  TrainingPredictions$Training <- 1
  TestingPredictions$Training <- NA
  FinalDataFrame <- rbind(TrainingPredictions,TestingPredictions)
  
  # Add moving average of predictions to slow trading
  MeanPrediction <- mean(FinalDataFrame$Prediction)
  SDPrediction <- sd(FinalDataFrame$Prediction,na.rm = TRUE) * DataLoadParameters$SDMultiplier
  FinalDataFrame$OrigPrediction <- FinalDataFrame$Prediction
  FinalDataFrame$Prediction <- FinalDataFrame$Prediction - MeanPrediction
  
  # Add dates and closing prices, along with actuals
  FinalDataFrame$Date <- DataFrame$Date
  FinalDataFrame$Close_Price <- DataFrame$Close_Price
  FinalDataFrame$Buy <- ifelse(FinalDataFrame$BuySellHold == 1,1,NA)
  FinalDataFrame$Sell <- ifelse(FinalDataFrame$BuySellHold == 0,1,NA)
  
  # Work out the buying and selling points
  FinalDataFrame$BuyPrediction <- ifelse(FinalDataFrame$Prediction > SDPrediction,1,NA)
  FinalDataFrame$SellPrediction <- ifelse(FinalDataFrame$Prediction < -SDPrediction,1,NA)
  
  # Display from the start of testing only
  FinalDataFrame <- subset(FinalDataFrame,Date > as.Date(DataLoadParameters$TestStartDate,"%Y%m%d"))
  
  # Work out the actual buy and sell means
  MeanBuy <- mean(FinalDataFrame$Close_Price * FinalDataFrame$Buy,na.rm = TRUE)
  MeanSell <- mean(FinalDataFrame$Close_Price * FinalDataFrame$Sell,na.rm = TRUE)
  
  # Work out the predicted buy and sell means
  MeanBuyPrediction <- mean(FinalDataFrame$Close_Price * FinalDataFrame$BuyPrediction,na.rm = TRUE)
  MeanSellPrediction <- mean(FinalDataFrame$Close_Price * FinalDataFrame$SellPrediction,na.rm = TRUE)
  
  # Calculate profit
  Profit <- round((MeanSellPrediction - MeanBuyPrediction)/MeanBuyPrediction*100,2)
  print(paste("%Profit",Profit))
  print(paste("Mean buy price",MeanBuyPrediction))
  print(paste("Mean Sell price",MeanSellPrediction))
  
  # All data plot
  HistoricPlot <- ggplot(DataFrame, aes(Date, Close_Price)) +
    geom_step(col="Darkgreen",aes(y=Close_Price)) +
    geom_point(col="red",aes(y=ifelse(MaxInWindow==1,Close_Price*MaxInWindow,NA)),size=3,alpha=0.4) +
    geom_point(col="blue",aes(y=ifelse(MinInWindow==1,Close_Price*MinInWindow,NA)),size=3,alpha=0.4) +
    theme(legend.position = "top") +
    labs(
      x = "Date",
      y = "Price",
  #title = paste("All data Buy and Sell Points",DataLoadParameters$Instrument),
  subtitle = paste("Historical Chart"))
  #                 "\n(created on",Sys.Date(),")"))
  
  # Prediction Only Plot
  PredictionPlot <- ggplot(FinalDataFrame, aes(Date, Prediction)) +
    geom_step(col="darkgreen",aes(y=OrigPrediction)) +
    geom_step(col="green",aes(y=Prediction)) +
    geom_step(col="purple",aes(y=MeanPrediction)) +
    geom_step(col="purple",aes(y=MeanPrediction+SDPrediction),alpha=0.8) +
    geom_step(col="purple",aes(y=MeanPrediction-SDPrediction),alpha=0.8) +
    #geom_step(col="black",aes(y=PredictionMALong)) +
    #geom_step(col="red",aes(y=PredictionMADiff)) +
    theme(legend.position = "top") +
    labs(
      x = "Date",
      y = "Prediction")
  #title = paste("Prediction Indicator",DataLoadParameters$Instrument),
  #subtitle = paste("Trading Window = ",DataLoadParameters$TradingTimeFrameInDays,"days giving profit of",Profit,"%",
  #                 "\nUsing",paste(DataLoadParameters$ColumnsToSelectForTraining,collapse=","),
  #                "\n(created on",Sys.Date(),")"))
  #print(PredictionPlot)
  
  # Final analysis plot
  BasicPlot <- ggplot(FinalDataFrame, aes(Date, Close_Price)) +
    geom_step(col="green",aes(y=Close_Price)) +
    geom_step(col="darkgreen",aes(y=Close_Price*Training)) +
    geom_point(col="blue",aes(y=Close_Price*BuyPrediction),size=3,alpha=0.4) +
    geom_point(col="red",aes(y=Close_Price*SellPrediction),size=3,alpha=0.4) +
    geom_hline(col="Darkblue",yintercept=MeanBuy,size=2,alpha=0.7) +
    geom_hline(col="Darkred",yintercept=MeanSell,size=2,alpha=0.7) +
    geom_hline(col="lightblue",yintercept=MeanBuyPrediction,size=2,alpha=0.4) +
    geom_hline(col="orange",yintercept=MeanSellPrediction,size=2,alpha=0.4) +
    theme(legend.position = "top") +
    labs(
      x = "",
      y = "Price",
      title = paste("Buy and Sell Points",DataLoadParameters$Instrument),
      subtitle = paste("Trading Window = ",DataLoadParameters$TradingTimeFrameInDays,"days giving profit of",Profit,"%",
                       "\n(created on",Sys.Date(),")"))
  
  library(gridExtra)
  QuickTable <- data.frame(Close=FinalDataFrame$Close,
                           Prediction=round(FinalDataFrame$Prediction,3),
                           Buy=FinalDataFrame$BuyPrediction,
                           Sell=FinalDataFrame$SellPrediction,
                           Profit=Profit)
  rownames(QuickTable) <- FinalDataFrame$Date
  MyTable <- tableGrob(tail(QuickTable,5))
  LastPlot <- grid.arrange(BasicPlot,HistoricPlot,PredictionPlot,MyTable, ncol=2)
  
  FileName <- paste("D:\\dropbox\\dropbox\\pdfs\\charts\\",DataLoadParameters$Instrument,".pdf",sep="")
  ggsave(FileName, width = 20, height = 20, units = "cm",LastPlot)
  
  FinalDataFrame$Profit <- Profit
  
  return(FinalDataFrame)
  
}

DataFrameMaxAndMins <- function(DataFrame)
{
  
  # Compute the max and mins for each column in the data frame
  Columns <- colnames(DataFrame)
  maxs <- apply(DataFrame, 2, max) 
  mins <- apply(DataFrame, 2, min)
  
  return(list(ColumnNames=Columns,Maximums=maxs,Minimums=mins))
  
}

## Quick summary of data we are using to compute the column type and number of levels
DataAnalysis <- function(DataFrame,
                         PredictionVariable="",
                         Title = "",
                         PrintExamples = TRUE,
                         DrawCharts = TRUE,
                         BeforePreProcessing = TRUE)
{
  
  print("Data Analysis of DataFrame")
  print("")
  
  if (is.data.frame(DataFrame) == TRUE)
  {
    
    Cols <- colnames(DataFrame)
    
    for (col in Cols)
    {
      
      # Select the column number
      ColNo <- which(Cols == col)
      print(paste("Column",col))
      print(paste("    No unique values =",length(unique(DataFrame[,ColNo]))))
      print(paste("    Class",class(DataFrame[,ColNo]),"with",length(levels(DataFrame[,ColNo])),"levels"))
      
      # Print top five unique items
      if (PrintExamples == TRUE)
      {
        # Now print the top 5 unique values in the column
        for (i in head(unique(DataFrame[,ColNo]),5)){print(paste("        ",col,"=",i))}
      }
      
      # Now print summary if not a factor
      if (class(DataFrame[,ColNo])!= "factor") {
        print(paste("    Min",min(DataFrame[,ColNo]),
                    "Median",median(DataFrame[,ColNo]),
                    "Mean",mean(DataFrame[,ColNo]),
                    "Max",max(DataFrame[,ColNo])))
      }
      
      print(" ")
      
      if (DrawCharts == TRUE)
      {
        if (col != PredictionVariable)
        {
          # Now plot the results
          Prediction <- which(Cols == PredictionVariable)
          PredictionCol <- DataFrame[,Prediction]
          ActualCol <- DataFrame[,ColNo]
          PlotDF <- data.frame(Prediction = PredictionCol, Actual = ActualCol)
          
          if (BeforePreProcessing == FALSE)
          {
            ResultsPlot <- ggplot(PlotDF,aes(x=Actual,y=Prediction)) +
              geom_point(aes(x=Actual,y=Prediction),
                         colour="Blue",
                         fill="DarkBlue",
                         size=0.5) +
              geom_smooth(method="lm") +
              ylab(paste(PredictionVariable,"- Predict Column")) +
              xlab(paste(col,"- Example Column")) +
              theme(plot.title = element_text(size = 12),
                    axis.title.x = element_text(size = 10),
                    axis.title.y = element_text(size = 10),
                    text = element_text(size = 8)) +
              ggtitle(paste(Title,"-",PredictionVariable,"versus",col))
            print(ResultsPlot)
          }
        }
        
        if (BeforePreProcessing == TRUE)
        {
          # Now plot the histograms
          ResultsPlot <- ggplot(PlotDF,aes(x=Actual)) +
            geom_histogram(aes(x=Actual),
                           colour="Blue",
                           fill="DarkBlue",
                           size=0.5) +
            ylab(paste("Count")) +
            xlab(paste(col,"- Example Column")) +
            theme(plot.title = element_text(size = 12),
                  axis.title.x = element_text(size = 10),
                  axis.title.y = element_text(size = 10),
                  text = element_text(size = 8)) +
            ggtitle(paste(Title,"-","Histogram",col))
          print(ResultsPlot)
        } 
      }
    }
    
  }
}



# Split function
SplitData <- function(DataFrame,PercentToSplit,SplitUsingSampleMethod=TRUE)
{
  # Will add index column
  DataFrame$x <- seq(1,nrow(DataFrame))
  
  ## Number of rows to sample
  smp_size <- floor(PercentToSplit * nrow(DataFrame))
  
  print(paste("Using training sample size of",smp_size,"using",PercentToSplit,"% split"))
  print(paste("From total data set of",nrow(DataFrame),"rows"))
  
  if (SplitUsingSampleMethod == TRUE)
  {
    
    print("Using sampling method to select training data")
    
    # Create sampling index
    train_ind <- sample(DataFrame$x, size = smp_size)
    
    # Now split te data into training and test
    train <- DataFrame[train_ind, ]
    test <- DataFrame[-train_ind, ]
    
  } else {
    
    print("Using first n% to select training data")
    
    # Use the first percentage and test with the remaining
    train <- DataFrame[1:smp_size,]
    test <- DataFrame[(smp_size+1):nrow(DataFrame),]
    
  }
  
  # Check nrows of both
  print(paste("Number of rows in training set ... ",nrow(train)))
  print(paste("Number of rows in testing set ... ",nrow(test)))
  
  
  # Now remove the x variable
  train$x <- NULL
  test$x <- NULL
  
  # Return list of data frames
  ReturnList <- list(train,test)
  
  return(ReturnList)
}

# Function to pre-process the data - First selects columns, then rescales, then splits
PreProcess <- function(DataFrame,
                       Columns = "",
                       ColumnNames = "",
                       Backtest=TRUE,
                       Debug=TRUE,
                       PercentageToSplit=0,
                       UseSampleMethod=TRUE,
                       OneHotEncodeFactors=FALSE,
                       Rescale=FALSE,
                       MaxValues="",
                       MinValues="")
{
  
  
  if (Debug==TRUE) {print("PreProcessing data")}
  
  # Generic code
  DataFrame <- DataFrame[,Columns]
  colnames(DataFrame) <- ColumnNames
  
  
  # Rescale all data using provided max and mins
  if (Rescale == TRUE)
  {
    if (Debug==TRUE) {print("    Rescaling data now")}
    
    i <- 0
    for (Column in colnames(DataFrame))
    {
      i <- i + 1
      DataColumn <- DataFrame[,Column]
      if (is.factor(DataColumn) == FALSE)
      {
        print(paste("     ",Column,"is not a factor"))
        Max <- MaxValues[i]
        Min <- MinValues[i]
        print(paste("     ",Column,"has max",Max,"and min",Min))
        DataFrame[,Column] <- scale(DataColumn,center = Min,scale = Max - Min)
        
      }
    }
    
  }
  
  # One hot encode all factors now
  if (OneHotEncodeFactors == TRUE)
  {
    if (Debug==TRUE) {print("    One hot encoding data now")}
    
    # First refactor all the factor columns
    DataFrame <- as.data.frame(lapply(DataFrame, function (x) if (is.factor(x)) factor(x) else x)) 
    
    # One hot encode all the data in the data frame
    DataFrame = as.data.frame(model.matrix(~.-1,DataFrame))    # Convert to matrix
    
    # Remove spaces from the column names and replace with little x
    names(DataFrame) <-gsub(" ","x", names(DataFrame))
    
  }
  
  
  # Split data
  ListOfDataFrames <- SplitData(DataFrame,PercentToSplit=PercentageToSplit,SplitUsingSampleMethod=UseSampleMethod)
  
  
  return(ListOfDataFrames)
}

TrainingModelRF <- function(DataFrame,
                            ColumnNames,
                            PredictVariable="",
                            NTrees=5,
                            Backtest=TRUE,
                            Debug=TRUE,
                            SaveModel=FALSE,
                            PlotImportance=TRUE,
                            FileName = "Model")
{
  if (Debug==TRUE) {print("Training on data using RF Model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  library(randomForest)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames]
  
  DataFrame <- cbind(VariableColumns,PredictVariable)
  
  #Print the fitting parameters
  if (Debug==TRUE) {print(paste("    Number of trees = ",NTrees))}
  
  # Train
  Model = randomForest(PredictVariable ~ . ,
                       data = DataFrame,
                       keep.forest=TRUE,
                       importance=TRUE,
                       ntree = NTrees)
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_RF.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_RF.rds",sep=""))}
  }
  
  # Plot importance
  if (PlotImportance == TRUE) {ImportancePlot(Model,"Example Importance Plot","Random Forest Model")}
  
  return(Model)
  
}

PredictRF <- function(DataFrame,
                      ColumnNames,
                      Model,
                      Backtest=TRUE,
                      Debug=TRUE,
                      LoadModel=FALSE,
                      FileName="Model",
                      PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from model and data using RF Model")}
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_RF.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_RF.rds",sep=""))}
  }
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames]
  
  DataFrame$Prediction <- predict(Model,VariableColumns)
  
  return(DataFrame)
}

####

TrainingModelDeepNet <- function(DataFrame,
                                 ColumnNames,
                                 PredictVariable="",
                                 Backtest=TRUE,
                                 Debug=TRUE,
                                 SaveModel=FALSE,
                                 FileName = "Model",
                                 activationfun = "sigm",   #  activation function of hidden unit.Can be "sigm","linear" or "tanh".Default is "sigm" for logistic function 
                                 learningrate  = 0.8,
                                 momentum      = 0.5,      # momentum for gradient descent. Default is 0.5
                                 learningrate_scale = 1,   # learning rate for gradient descent. Default is 0.8. 
                                 output        = "sigm",
                                 numepochs     = 100,      # increase to add accuracy
                                 batchsize    = 100,       # size of mini-batch. Default is 100.
                                 hidden_dropout = 0,       #  drop out fraction for hidden layer. Default is 0. 
                                 visible_dropout = 0)
{
  if (Debug==TRUE) {print("Training on data using DeepNet Model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames]
  
  # Convert to matrix
  VariableColumns <- as.matrix(VariableColumns)
  
  library(deepnet)
  Model <- dbn.dnn.train(VariableColumns, PredictVariable, hidden = c(5, 5),
                         activationfun = activationfun,   #  activation function of hidden unit.Can be "sigm","linear" or "tanh".Default is "sigm" for logistic function 
                         learningrate  = learningrate,
                         momentum      = momentum,      # momentum for gradient descent. Default is 0.5
                         learningrate_scale = learningrate_scale,   # learning rate for gradient descent. Default is 0.8. 
                         output        = output,
                         numepochs     = numepochs,      # increase to add accuracy
                         batchsize    = batchsize,       # size of mini-batch. Default is 100.
                         hidden_dropout = hidden_dropout,       #  drop out fraction for hidden layer. Default is 0. 
                         visible_dropout = visible_dropout)
  
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_DeepNet.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_DeepNet.rds",sep=""))}
  }
  
  return(Model)
  
}

PredictDeepNet <- function(DataFrame,
                           ColumnNames,
                           Model,
                           Backtest=TRUE,
                           Debug=TRUE,
                           LoadModel=FALSE,
                           FileName="Model",
                           PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from model and data using DeepNet Model")}
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_DeepNet.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_DeepNet.rds",sep=""))}
  }
  
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames]
  
  # Convert to matrix
  VariableColumns <- as.matrix(VariableColumns)
  
  # Prediction
  DataFrame$Prediction <- nn.predict(Model, VariableColumns)
  
  
  return(DataFrame)
}

###

TrainingModelRFRLT <- function(DataFrame,
                               ColumnNames,
                               PredictVariable="",
                               NTrees=10,
                               Backtest=TRUE,
                               Debug=TRUE,
                               SaveModel=FALSE,
                               PlotImportance=TRUE,
                               RegType="",
                               FileName = "Model")
{
  if (Debug==TRUE) {print("Training on data using RFRLT model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  if (Debug==TRUE) {print(paste("Using No Tress ....",NTrees))}
  if (Debug==TRUE) {print(paste("Using model ....",RegType))}
  
  library(RLT)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames]
  
  # Run model
  Model = RLT(VariableColumns, PredictVariable,
              model = RegType, #  regression, classification or survival 
              use.cores = 7,
              ntrees = NTrees,
              importance = PlotImportance, 
              reinforcement = TRUE,
              combsplit = 20,
              embed.ntrees = NTrees)
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_RF_RLT.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_RF_RLT.rds",sep=""))}
  }
  
  # Plot importance
  if (PlotImportance == TRUE) {barplot(Model$VarImp)}
  
  return(Model)
  
}

PredictRFRLT <- function(DataFrame,
                         ColumnNames,
                         Model,
                         Backtest=TRUE,
                         Debug=TRUE,
                         LoadModel=TRUE,
                         FileName="Model",
                         PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from RF RLT model and data")}
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames]
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_RF_RLT.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_RF_RLT.rds",sep=""))}
  }
  
  PredictionList <- predict(Model,VariableColumns)
  
  DataFrame$Prediction <- PredictionList[[2]]   # Select only the predictions
  
  return(DataFrame)
  
}

TrainingModelSVM <- function(DataFrame,
                             ColumnNames,
                             PredictVariable="",
                             Backtest=TRUE,
                             Debug=TRUE,
                             SaveModel=FALSE,
                             PlotImportance=TRUE,
                             FileName="Model")
{
  
  if (Debug==TRUE) {print("Training on data using Support Vector Machine")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  library(e1071)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames]
  
  Model <- svm(VariableColumns, PredictVariable,kernel = "linear")
  
  if (PlotImportance==TRUE)
  {
    print(summary(Model))
  }
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_SVM.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_SVM.rds",sep=""))}
  }
  
  return(Model)
  
}


PredictSVM <- function(DataFrame,ColumnNames,Model,
                       Backtest=TRUE,
                       Debug=TRUE,
                       LoadModel=FALSE,
                       FileName="Model",
                       PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from data using Support Vector Machine model")}
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames]
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_SVM.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_SVM.rds",sep=""))}
  }
  
  PredictionList <- predict(Model,VariableColumns)
  
  DataFrame$Prediction <- PredictionList   
  
  return(DataFrame)
  
}

# Call neural network and return the model of the network
TrainingModelNN <- function(DataFrame,
                            ColumnNames="",
                            PredictVariable="",
                            HiddenNodes="",
                            Backtest=TRUE,
                            Debug=TRUE,
                            SaveModel=TRUE,
                            FileName = "",
                            Iterations = 0)
{
  
  library(neuralnet)
  library(nnet)
  
  
  HiddenLayers <- paste(HiddenNodes,collapse=",")
  if (Debug==TRUE) {print(paste("Training on data using hidden layers of ",HiddenLayers))}
  
  # Get all column names minus the prediction variable
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames]
  
  # Now create a df will both
  PredictVariableDF <- DataFrame[,PredictVariable]
  DataFrame <- cbind(VariableColumns,PredictVariableDF)
  
  n <- names(VariableColumns)
  
  f <- as.formula(paste("PredictVariableDF ~", paste(n[!n %in% PredictVariable], collapse = " + ")))
  
  Model = nnet(f,data=DataFrame,
               size=HiddenNodes,
               linout=T,
               decay=0.07,
               maxit=Iterations)
  
  #Model <- neuralnet(f,data=DataFrame,hidden=HiddenNodes,linear.output=T) # Linear.output = TRUE for regression
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_NeuralNetworkModel.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_NeuralNetworkModel.rds",sep=""))}
  }
  
  return(Model)
  
}

# Use model to predict results
# Take extreame care when editing this function to ensure no contamination of results
PredictNN <- function(DataFrame="",
                      PredictVariable="",
                      ColumnNames="",
                      Model,
                      Backtest=TRUE,
                      Debug=TRUE,
                      LoadModel=TRUE,
                      FileName = "")
{
  
  if (Debug==TRUE) {print("Predicting from model and data")}
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_NeuralNetworkModel.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_NeuralNetworkModel.rds",sep=""))}
  }
  
  # Get all column names minus the prediction variable
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames]
  
  #Results <- compute(Model,VariableColumns)
  Results = predict(Model, VariableColumns)
  
  DataFrame$Prediction <- Results  
  
  return(DataFrame)
  
}

TrainingModelKNN <- function(DataFrame,
                             ColumnNames,
                             PredictVariable="",
                             K=10,
                             Backtest=TRUE,
                             Debug=TRUE,
                             SaveModel=FALSE,
                             PlotImportance=TRUE,
                             RegType="",
                             FileName = "Model")
{
  if (Debug==TRUE) {print("Training on data using KNN model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  library(caret)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames]
  
  # Run model
  Model = knnreg(VariableColumns, PredictVariable,k = K)
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_KNN.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_KNN.rds",sep=""))}
  }
  
  return(Model)
  
}

PredictKNN <- function(DataFrame,
                       ColumnNames,
                       Model,
                       Backtest=TRUE,
                       Debug=TRUE,
                       LoadModel=TRUE,
                       FileName="Model",
                       PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from KNN model and data")}
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames]
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_KNN.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_KNN.rds",sep=""))}
  }
  
  Prediction <- predict(Model, VariableColumns)
  
  DataFrame$Prediction <- Prediction   # Select only the predictions
  
  return(DataFrame)
  
}

TrainingModelXGBoost <- function(DataFrame,
                                 ColumnNames,
                                 PredictVariable="",
                                 Backtest=TRUE,
                                 Debug=TRUE,
                                 SaveModel=FALSE,
                                 PlotImportance=TRUE,
                                 RegType="",
                                 FileName = "Model")
{
  
  if (Debug==TRUE) {print("Training on data using XGBoost model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  library(xgboost)
  
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames]
  
  # Train
  Model <- xgboost(data = data.matrix(VariableColumns),
                   label = PredictVariable,
                   booster="gblinear",     # Defaul = gbtree
                   max_depth = 6,
                   eta = 0.3,
                   gamma = 0,
                   subsample=0.5,
                   nthread = 6,
                   nrounds = 200,
                   objective = "binary:logistic",
                   verbose = FALSE)
  
  if (PlotImportance == TRUE)
  {
    # Plot the top 10 variables
    importance_matrix <- xgb.importance(VariableNames, model = Model)
    xgb.plot.importance(importance_matrix[1:10,])
  }
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_XGBoost.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_XGBoost.rds",sep=""))}
  }
  
  return(Model)
  
}

PredictXGBoost <- function(DataFrame,
                           ColumnNames,
                           Model,
                           Backtest=TRUE,
                           Debug=TRUE,
                           LoadModel=TRUE,
                           FileName="Model",
                           PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from XGBoost model and data")}
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames]
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_XGBoost.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_XGBoost.rds",sep=""))}
  }
  
  # Predict
  Prediction <- predict(Model, data.matrix(VariableColumns))
  
  DataFrame$Prediction <- Prediction   # Select only the predictions
  
  return(DataFrame)
  
}

# Rescales and Handles the testing of the accuracy of fit
PostProcess <- function(DataFrame,
                        PredictVariable="",
                        Backtest=TRUE,
                        Debug=TRUE,
                        TestingSet=FALSE,
                        RegressionModel="",
                        Variable="",
                        RegType="",
                        DrawCharts = FALSE,
                        Rescale=FALSE,
                        MaxValues="",
                        MinValues="",
                        ColumnNames="")
{
  
  if (TestingSet == FALSE)
  {
    Item <- "Training Set"
    Title = paste("Training Data with",RegressionModel,"model predicting",Variable)
    if (Debug==TRUE) {print(paste("Post processing training data after running",RegressionModel,"model predicting",Variable))}
  } else {
    Item <- "Test Set"
    Title = paste("Testing Data with",RegressionModel,"model predicting",Variable)
    if (Debug==TRUE) {print(paste("Post processing testing data after running",RegressionModel,"model predicting",Variable))}
  }
  
  # Extract the predicted variable
  DataFrame$Actual <- DataFrame[,PredictVariable]
  
  # Now rescale the predicted variable if it was not a factor
  if (Rescale==TRUE)
  {
    if (Debug==TRUE) {print(paste("Rescaling prediction variable",PredictVariable))}
    
    # Find the prediction parameter in the columns list
    PredictCol <- which(ColumnNames==PredictVariable)
    
    # rescale now
    DataFrame$Prediction <- DataFrame$Prediction * (MaxValues[PredictCol] - MinValues[PredictCol]) + MinValues[PredictCol]
    DataFrame$Actual <- DataFrame$Actual * (MaxValues[PredictCol] - MinValues[PredictCol]) + MinValues[PredictCol]
  }
  
  # Handle x y type regression results
  if (RegType =="regression")
  {
    # reformat data
    DataFrame$Error <- DataFrame$Prediction - DataFrame$Actual
    
    # Calculate the RMSE and return it as part of the function
    RMSE <- sqrt(mean(DataFrame$Error^2))
    ReturnDataFrame <- data.frame(Desc=paste(Item,"RMS Error"),RMSE=RMSE)
    print(ReturnDataFrame)
    
    if (DrawCharts == TRUE)
    {
      # Now plot the results
      ResultsPlot <- ggplot(DataFrame,aes(x=Actual,y=Prediction)) +
        geom_point(aes(x=Actual,y=Prediction),
                   colour="Blue",
                   fill="DarkBlue") +
        geom_smooth(method="lm") +
        xlab("Actual Value") +
        ylab("Prediction") +
        theme(plot.title = element_text(size = 12),
              axis.title.x = element_text(size = 10),
              axis.title.y = element_text(size = 10),
              text = element_text(size = 8)) +
        ggtitle(paste("Actual versus Predicted - ",Title))
      print(ResultsPlot)
    }
  }
  
  # Handle classification problems
  if (RegType =="classification")
  {
    # Work out if not equal
    DataFrame$Error <- ifelse(DataFrame$Prediction == PredictVariable, 1, 0)
    print(DataFrame)
    
    # find errors
    ErrorsFrame <- subset(DataFrame,DataFrame$Prediction != DataFrame$Actual)
    print(paste("Number of rows predicted",nrow(DataFrame)))
    print(paste("Number of errors found",nrow(ErrorsFrame)))
    
    ReturnDataFrame <- ErrorsFrame
    
  }
  
  if (Debug==TRUE) {print(paste("Returning dataframe with results"))}
  
  return(DataFrame)
  
}

ImportancePlot <- function(Model,Title="",SubTitle="",Caption="")
{
  
  library(ggplot2)
  
  MeanDecreaseGini <- importance(Model)
  MeanDecreaseGini <- as.data.frame(MeanDecreaseGini)
  MeanDecreaseGini$Variable <- rownames(MeanDecreaseGini)
  
  ImpPlot <- ggplot(data = MeanDecreaseGini, aes(Variable, IncNodePurity)) +
    geom_bar(stat = "identity", position = "dodge",colour="red",alpha=0.8,fill="red") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    labs(caption = Caption) +
    ggtitle(Title,
            subtitle = paste(SubTitle)) 
  print(ImpPlot)
}


###############################################################################
#
#   Data Analysis Code
#
#   Use this function to load your data and draw charts of your data 
#
###############################################################################

MLDataAnalysis <- function(MLParameterList,DataLoadParameters)
{
  
  # Load data
  DataFrame <- DataLoadAndFormat(Backtest=MLParameterList$BackTest,
                                 Debug=MLParameterList$Debug,
                                 ConvertToFactors=MLParameterList$ConvertToFactors,
                                 DataLoadParameters)
  
  if (is.na(DataFrame) == FALSE)
  {
    
    # Check data formats before pre-processing
    DataAnalysis(DataFrame,
                 PredictionVariable  = MLParameterList$PredictionVariable,
                 Title               = MLParameterList$ProjectTitle,
                 PrintExamples       = MLParameterList$PrintExamplesinAnalysis,
                 DrawCharts          = MLParameterList$DrawChartsinAnalysis,
                 BeforePreProcessing = TRUE)
    
    # Pre-Process
    ListOfDataFrames <- PreProcess(DataFrame,
                                   Columns = MLParameterList$ColumnsToSelectForTraining,
                                   ColumnNames = MLParameterList$DisplayColumnNames,
                                   Backtest = MLParameterList$BackTest,
                                   Debug = MLParameterList$Debug,
                                   PercentageToSplit = MLParameterList$SplitPercent,
                                   UseSampleMethod = MLParameterList$SamplingMethod,
                                   OneHotEncodeFactors=MLParameterList$OneHotEncodeFactors,
                                   Rescale=MLParameterList$Rescale,
                                   MaxValues=MLParameterList$Maximums,
                                   MinValues=MLParameterList$Minimums)
    
    # Check data formats after pre-processing
    DataAnalysis(ListOfDataFrames[[1]],
                 PredictionVariable  = MLParameterList$PredictionVariable,
                 Title               = MLParameterList$ProjectTitle,
                 PrintExamples       = MLParameterList$PrintExamplesinAnalysis,
                 DrawCharts          = MLParameterList$DrawChartsinAnalysis,
                 BeforePreProcessing = FALSE)
    
    # Display max and mins from training set
    print("Max and min values from training set")
    print(DataFrameMaxAndMins(ListOfDataFrames[[1]]))
  }
}

###############################################################################
#
#   Training Code
#
###############################################################################

MLTraining <- function(MLParameterList,DataLoadParameters)
{
  
  # Load data
  DataFrame <- DataLoadAndFormat(Backtest=MLParameterList$BackTest,
                                 Debug=MLParameterList$Debug,
                                 ConvertToFactors=MLParameterList$ConvertToFactors,
                                 DataLoadParameters)
  if (is.na(DataFrame) == FALSE)
  {
    
    if (nrow(DataFrame)>500) 
    {
      
      # Pre-Process
      ListOfDataFrames <- PreProcess(DataFrame,
                                     Columns = MLParameterList$ColumnsToSelectForTraining,
                                     ColumnNames = MLParameterList$DisplayColumnNames,
                                     Backtest = MLParameterList$BackTest,
                                     Debug = MLParameterList$Debug,
                                     PercentageToSplit = MLParameterList$SplitPercent,
                                     UseSampleMethod = MLParameterList$SamplingMethod,
                                     OneHotEncodeFactors=MLParameterList$OneHotEncodeFactors,
                                     Rescale=MLParameterList$Rescale,
                                     MaxValues=MLParameterList$Maximums,
                                     MinValues=MLParameterList$Minimums)
      
      # Check data formats after pre-processing
      DataAnalysis(ListOfDataFrames[[1]],
                   PredictionVariable  = MLParameterList$PredictionVariable,
                   Title               = MLParameterList$ProjectTitle,
                   PrintExamples       = MLParameterList$PrintExamplesinAnalysis,
                   DrawCharts          = MLParameterList$DrawChartsinAnalysis)
      
      if (MLParameterList$RegressionModel == "SVM")
      {
        print("Training with Support Vector Machine")
        
        # Training
        Model <-     TrainingModelSVM(ListOfDataFrames[[1]],
                                      ColumnNames     = MLParameterList$VariableNames,
                                      PredictVariable = MLParameterList$PredictionVariable,
                                      Backtest        = MLParameterList$BackTest,
                                      Debug           = MLParameterList$Debug,
                                      SaveModel       = MLParameterList$SaveModelToFile,
                                      PlotImportance  = MLParameterList$DrawImportanceCharts,
                                      FileName        = MLParameterList$FileNameOfModel)
        
        # Predict from training
        TrainingPredictions <- PredictSVM(ListOfDataFrames[[1]],
                                          ColumnNames = MLParameterList$VariableNames,
                                          Model       = Model,
                                          Backtest    = MLParameterList$BackTest,
                                          Debug       = MLParameterList$Debug,
                                          LoadModel   = MLParameterList$SaveModelToFile,
                                          FileName    = MLParameterList$FileNameOfModel,
                                          PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                                PredictVariable     = MLParameterList$PredictionVariable,
                                                Backtest            = MLParameterList$BackTest,
                                                Debug               = MLParameterList$Debug,
                                                TestingSet          = FALSE,
                                                RegressionModel     = MLParameterList$RegressionModel,
                                                Variable            = MLParameterList$PredictionVariable,
                                                RegType             = MLParameterList$RegressionType,
                                                DrawCharts          = MLParameterList$DrawChartsOfResults,
                                                Rescale=MLParameterList$Rescale,
                                                MaxValues=MLParameterList$Maximums,
                                                MinValues=MLParameterList$Minimums,
                                                ColumnNames=MLParameterList$DisplayColumnNames)
        
        
        # Predict testing set
        TestingPredictions <- PredictSVM(ListOfDataFrames[[2]],
                                         ColumnNames = MLParameterList$VariableNames,
                                         Model       = Model,
                                         Backtest    = MLParameterList$BackTest,
                                         Debug       = MLParameterList$Debug,
                                         LoadModel   = MLParameterList$SaveModelToFile,
                                         FileName    = MLParameterList$FileNameOfModel,
                                         PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                               PredictVariable     = MLParameterList$PredictionVariable,
                                               Backtest            = MLParameterList$BackTest,
                                               Debug               = MLParameterList$Debug,
                                               TestingSet          = TRUE,
                                               RegressionModel     = MLParameterList$RegressionModel,
                                               Variable            = MLParameterList$PredictionVariable,
                                               RegType             = MLParameterList$RegressionType,
                                               DrawCharts          = MLParameterList$DrawChartsOfResults,
                                               Rescale=MLParameterList$Rescale,
                                               MaxValues=MLParameterList$Maximums,
                                               MinValues=MLParameterList$Minimums,
                                               ColumnNames=MLParameterList$DisplayColumnNames)
        
        Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
        
      }
      
      if (MLParameterList$RegressionModel == "RF")
      {
        
        print("Training with Random Forrest - Original version")
        
        # Training
        Model <-     TrainingModelRF(ListOfDataFrames[[1]],
                                     ColumnNames            = MLParameterList$VariableNames,
                                     PredictVariable        = MLParameterList$PredictionVariable,
                                     NTrees                 = MLParameterList$NumberOfTrees,
                                     Backtest               = MLParameterList$BackTest,
                                     Debug                  = MLParameterList$Debug,
                                     SaveModel              = MLParameterList$SaveModelToFile,
                                     PlotImportance         = MLParameterList$DrawImportanceCharts,
                                     FileName               = MLParameterList$FileNameOfModel)
        
        
        # Predict from training
        TrainingPredictions <- PredictRF(ListOfDataFrames[[1]],
                                         ColumnNames            = MLParameterList$VariableNames,
                                         Model                  = Model,
                                         Backtest               = MLParameterList$BackTest,
                                         Debug                  = MLParameterList$Debug,
                                         LoadModel              = MLParameterList$SaveModelToFile,
                                         FileName               = MLParameterList$FileNameOfModel,
                                         PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                                PredictVariable     = MLParameterList$PredictionVariable,
                                                Backtest            = MLParameterList$BackTest,
                                                Debug               = MLParameterList$Debug,
                                                TestingSet          = FALSE,
                                                RegressionModel     = MLParameterList$RegressionModel,
                                                Variable            = MLParameterList$PredictionVariable,
                                                RegType             = MLParameterList$RegressionType,
                                                DrawCharts          = MLParameterList$DrawChartsOfResults,
                                                Rescale=MLParameterList$Rescale,
                                                MaxValues=MLParameterList$Maximums,
                                                MinValues=MLParameterList$Minimums,
                                                ColumnNames=MLParameterList$DisplayColumnNames)
        
        # Predict testing set
        TestingPredictions <- PredictRF(ListOfDataFrames[[2]],
                                        ColumnNames            = MLParameterList$VariableNames,
                                        Model                  = Model,
                                        Backtest               = MLParameterList$BackTest,
                                        Debug                  = MLParameterList$Debug,
                                        LoadModel              = MLParameterList$SaveModelToFile,
                                        FileName               = MLParameterList$FileNameOfModel,
                                        PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                               PredictVariable     = MLParameterList$PredictionVariable,
                                               Backtest            = MLParameterList$BackTest,
                                               Debug               = MLParameterList$Debug,
                                               TestingSet          = TRUE,
                                               RegressionModel     = MLParameterList$RegressionModel,
                                               Variable            = MLParameterList$PredictionVariable,
                                               RegType             = MLParameterList$RegressionType,
                                               DrawCharts          = MLParameterList$DrawChartsOfResults,
                                               Rescale=MLParameterList$Rescale,
                                               MaxValues=MLParameterList$Maximums,
                                               MinValues=MLParameterList$Minimums,
                                               ColumnNames=MLParameterList$DisplayColumnNames)
        
        Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
        
      }
      
      if (MLParameterList$RegressionModel == "DEEPNET")
      {
        
        print("Training with DEEPNET")
        
        # Training
        Model <-     TrainingModelDeepNet(ListOfDataFrames[[1]],
                                          ColumnNames            = MLParameterList$VariableNames,
                                          PredictVariable        = MLParameterList$PredictionVariable,
                                          Backtest               = MLParameterList$BackTest,
                                          Debug                  = MLParameterList$Debug,
                                          SaveModel              = MLParameterList$SaveModelToFile,
                                          FileName               = MLParameterList$FileNameOfModel,
                                          activationfun          = MLParameterList$activationfun,
                                          learningrate           = MLParameterList$learningrate,
                                          momentum               = MLParameterList$momentum,
                                          learningrate_scale     = MLParameterList$learningrate_scale,
                                          output                 = MLParameterList$output,
                                          numepochs              = MLParameterList$numepochs,           
                                          batchsize              = MLParameterList$batchsize,          
                                          hidden_dropout         = MLParameterList$hidden_dropout,     
                                          visible_dropout        = MLParameterList$visible_dropout)
        
        
        # Predict from training
        TrainingPredictions <- PredictDeepNet(ListOfDataFrames[[1]],
                                              ColumnNames            = MLParameterList$VariableNames,
                                              Model                  = Model,
                                              Backtest               = MLParameterList$BackTest,
                                              Debug                  = MLParameterList$Debug,
                                              LoadModel              = MLParameterList$SaveModelToFile,
                                              FileName               = MLParameterList$FileNameOfModel,
                                              PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                                PredictVariable     = MLParameterList$PredictionVariable,
                                                Backtest            = MLParameterList$BackTest,
                                                Debug               = MLParameterList$Debug,
                                                TestingSet          = FALSE,
                                                RegressionModel     = MLParameterList$RegressionModel,
                                                Variable            = MLParameterList$PredictionVariable,
                                                RegType             = MLParameterList$RegressionType,
                                                DrawCharts          = MLParameterList$DrawChartsOfResults,
                                                Rescale=MLParameterList$Rescale,
                                                MaxValues=MLParameterList$Maximums,
                                                MinValues=MLParameterList$Minimums,
                                                ColumnNames=MLParameterList$DisplayColumnNames)
        
        # Predict testing set
        TestingPredictions <- PredictDeepNet(ListOfDataFrames[[2]],
                                             ColumnNames            = MLParameterList$VariableNames,
                                             Model                  = Model,
                                             Backtest               = MLParameterList$BackTest,
                                             Debug                  = MLParameterList$Debug,
                                             LoadModel              = MLParameterList$SaveModelToFile,
                                             FileName               = MLParameterList$FileNameOfModel,
                                             PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                               PredictVariable     = MLParameterList$PredictionVariable,
                                               Backtest            = MLParameterList$BackTest,
                                               Debug               = MLParameterList$Debug,
                                               TestingSet          = TRUE,
                                               RegressionModel     = MLParameterList$RegressionModel,
                                               Variable            = MLParameterList$PredictionVariable,
                                               RegType             = MLParameterList$RegressionType,
                                               DrawCharts          = MLParameterList$DrawChartsOfResults,
                                               Rescale=MLParameterList$Rescale,
                                               MaxValues=MLParameterList$Maximums,
                                               MinValues=MLParameterList$Minimums,
                                               ColumnNames=MLParameterList$DisplayColumnNames)
        
        Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
        
      }
      
      if (MLParameterList$RegressionModel == "RFRLT")
      {
        print("Training with Random Forrest - RLT version")
        
        # Training
        Model <-     TrainingModelRFRLT(ListOfDataFrames[[1]],
                                        ColumnNames       = MLParameterList$VariableNames,
                                        PredictVariable   = MLParameterList$PredictionVariable,
                                        NTrees            = MLParameterList$NumberOfTrees,
                                        SaveModel         = MLParameterList$SaveModelToFile,
                                        PlotImportance    = MLParameterList$DrawImportanceCharts,
                                        RegType           = MLParameterList$RegressionType,
                                        FileName          = MLParameterList$FileNameOfModel)
        
        
        # Predict from training
        TrainingPredictions <- PredictRFRLT(ListOfDataFrames[[1]],
                                            ColumnNames       = MLParameterList$VariableNames,
                                            Model             = Model,
                                            Backtest          = MLParameterList$BackTest,
                                            Debug             = MLParameterList$Debug,
                                            LoadModel         = MLParameterList$SaveModelToFile,
                                            FileName          = MLParameterList$FileNameOfModel,
                                            PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                                PredictVariable     = MLParameterList$PredictionVariable,
                                                Backtest            = MLParameterList$BackTest,
                                                Debug               = MLParameterList$Debug,
                                                TestingSet          = FALSE,
                                                RegressionModel     = MLParameterList$RegressionModel,
                                                Variable            = MLParameterList$PredictionVariable,
                                                RegType             = MLParameterList$RegressionType,
                                                DrawCharts          = MLParameterList$DrawChartsOfResults,
                                                Rescale=MLParameterList$Rescale,
                                                MaxValues=MLParameterList$Maximums,
                                                MinValues=MLParameterList$Minimums,
                                                ColumnNames=MLParameterList$DisplayColumnNames)
        
        # Predict testing set
        TestingPredictions <- PredictRFRLT(ListOfDataFrames[[2]],
                                           ColumnNames       = MLParameterList$VariableNames,
                                           Model             = Model,
                                           Backtest          = MLParameterList$BackTest,
                                           Debug             = MLParameterList$Debug,
                                           LoadModel         = MLParameterList$SaveModelToFile,
                                           FileName          = MLParameterList$FileNameOfModel,
                                           PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                               PredictVariable     = MLParameterList$PredictionVariable,
                                               Backtest            = MLParameterList$BackTest,
                                               Debug               = MLParameterList$Debug,
                                               TestingSet          = TRUE,
                                               RegressionModel     = MLParameterList$RegressionModel,
                                               Variable            = MLParameterList$PredictionVariable,
                                               RegType             = MLParameterList$RegressionType,
                                               DrawCharts          = MLParameterList$DrawChartsOfResults,
                                               Rescale=MLParameterList$Rescale,
                                               MaxValues=MLParameterList$Maximums,
                                               MinValues=MLParameterList$Minimums,
                                               ColumnNames=MLParameterList$DisplayColumnNames)
        
        Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
        
      }
      
      if (MLParameterList$RegressionModel == "NN")
      {
        
        print("Training with Neural Network version")
        
        # Training
        Model <-     TrainingModelNN(ListOfDataFrames[[1]],
                                     ColumnNames    = MLParameterList$ColumnsToSelectForTraining,
                                     PredictVariable= MLParameterList$PredictionVariable,
                                     HiddenNodes    = MLParameterList$HiddenLayersStructure,
                                     Backtest       = MLParameterList$BackTest,
                                     Debug          = MLParameterList$Debug,
                                     SaveModel      = MLParameterList$SaveModelToFile,
                                     FileName        = MLParameterList$FileNameOfModel,
                                     Iterations      = MLParameterList$Iterations)
        
        # Predict training set
        TrainingPredictions <- PredictNN(DataFrame=ListOfDataFrames[[1]],
                                         PredictVariable =  MLParameterList$PredictionVariable,
                                         ColumnNames     =  MLParameterList$DisplayColumnNames,
                                         Model,
                                         Backtest        =  MLParameterList$BackTest,
                                         Debug           =  MLParameterList$Debug,
                                         LoadModel       =  MLParameterList$SaveModelToFile,
                                         FileName        =  MLParameterList$FileNameOfModel)
        
        # Do results processing
        TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                                PredictVariable     = MLParameterList$PredictionVariable,
                                                Backtest            = MLParameterList$BackTest,
                                                Debug               = MLParameterList$Debug,
                                                TestingSet          = FALSE,
                                                RegressionModel     = MLParameterList$RegressionModel,
                                                Variable            = MLParameterList$PredictionVariable,
                                                RegType             = MLParameterList$RegressionType,
                                                DrawCharts          = MLParameterList$DrawChartsOfResults,
                                                Rescale=MLParameterList$Rescale,
                                                MaxValues=MLParameterList$Maximums,
                                                MinValues=MLParameterList$Minimums,
                                                ColumnNames=MLParameterList$DisplayColumnNames)
        
        # Predict training set
        TestingPredictions <- PredictNN(DataFrame=ListOfDataFrames[[2]],
                                        PredictVariable =  MLParameterList$PredictionVariable,
                                        ColumnNames     =  MLParameterList$DisplayColumnNames,
                                        Model,
                                        Backtest        =  MLParameterList$BackTest,
                                        Debug           =  MLParameterList$Debug,
                                        LoadModel       =  MLParameterList$SaveModelToFile,
                                        FileName        =  MLParameterList$FileNameOfModel)
        
        # Do results processing
        TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                               PredictVariable     = MLParameterList$PredictionVariable,
                                               Backtest            = MLParameterList$BackTest,
                                               Debug               = MLParameterList$Debug,
                                               TestingSet          = TRUE,
                                               RegressionModel     = MLParameterList$RegressionModel,
                                               Variable            = MLParameterList$PredictionVariable,
                                               RegType             = MLParameterList$RegressionType,
                                               DrawCharts          = MLParameterList$DrawChartsOfResults,
                                               Rescale=MLParameterList$Rescale,
                                               MaxValues=MLParameterList$Maximums,
                                               MinValues=MLParameterList$Minimums,
                                               ColumnNames=MLParameterList$DisplayColumnNames)
        
        
        Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
      }
      
      # Use KNN model to train and predict
      if (MLParameterList$RegressionModel == "KNN")
      {
        print("Training with K nearest neighbour")
        
        # Training
        Model <-     TrainingModelKNN(ListOfDataFrames[[1]],
                                      ColumnNames       = MLParameterList$VariableNames,
                                      PredictVariable   = MLParameterList$PredictionVariable,
                                      K                 = MLParameterList$K,
                                      SaveModel         = MLParameterList$SaveModelToFile,
                                      PlotImportance    = MLParameterList$DrawImportanceCharts,
                                      RegType           = MLParameterList$RegressionType,
                                      FileName          = MLParameterList$FileNameOfModel)
        
        
        # Predict from training
        TrainingPredictions <- PredictKNN(ListOfDataFrames[[1]],
                                          ColumnNames       = MLParameterList$VariableNames,
                                          Model             = Model,
                                          Backtest          = MLParameterList$BackTest,
                                          Debug             = MLParameterList$Debug,
                                          LoadModel         = MLParameterList$SaveModelToFile,
                                          FileName          = MLParameterList$FileNameOfModel,
                                          PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                                PredictVariable     = MLParameterList$PredictionVariable,
                                                Backtest            = MLParameterList$BackTest,
                                                Debug               = MLParameterList$Debug,
                                                TestingSet          = FALSE,
                                                RegressionModel     = MLParameterList$RegressionModel,
                                                Variable            = MLParameterList$PredictionVariable,
                                                RegType             = MLParameterList$RegressionType,
                                                DrawCharts          = MLParameterList$DrawChartsOfResults,
                                                Rescale=MLParameterList$Rescale,
                                                MaxValues=MLParameterList$Maximums,
                                                MinValues=MLParameterList$Minimums,
                                                ColumnNames=MLParameterList$DisplayColumnNames)
        
        # Predict testing set
        TestingPredictions <- PredictKNN(ListOfDataFrames[[2]],
                                         ColumnNames       = MLParameterList$VariableNames,
                                         Model             = Model,
                                         Backtest          = MLParameterList$BackTest,
                                         Debug             = MLParameterList$Debug,
                                         LoadModel         = MLParameterList$SaveModelToFile,
                                         FileName          = MLParameterList$FileNameOfModel,
                                         PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                               PredictVariable     = MLParameterList$PredictionVariable,
                                               Backtest            = MLParameterList$BackTest,
                                               Debug               = MLParameterList$Debug,
                                               TestingSet          = TRUE,
                                               RegressionModel     = MLParameterList$RegressionModel,
                                               Variable            = MLParameterList$PredictionVariable,
                                               RegType             = MLParameterList$RegressionType,
                                               DrawCharts          = MLParameterList$DrawChartsOfResults,
                                               Rescale=MLParameterList$Rescale,
                                               MaxValues=MLParameterList$Maximums,
                                               MinValues=MLParameterList$Minimums,
                                               ColumnNames=MLParameterList$DisplayColumnNames)
        
        Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
        
      }
      
      # Use XGBoost model to train and predict
      if (MLParameterList$RegressionModel == "XGB")
      {
        print("Training with XGBoost nearest neighbour")
        
        # Training
        Model <-     TrainingModelXGBoost(ListOfDataFrames[[1]],
                                          ColumnNames       = MLParameterList$VariableNames,
                                          PredictVariable   = MLParameterList$PredictionVariable,
                                          SaveModel         = MLParameterList$SaveModelToFile,
                                          PlotImportance    = MLParameterList$DrawImportanceCharts,
                                          RegType           = MLParameterList$RegressionType,
                                          FileName          = MLParameterList$FileNameOfModel)
        
        
        # Predict from training
        TrainingPredictions <- PredictXGBoost(ListOfDataFrames[[1]],
                                              ColumnNames       = MLParameterList$VariableNames,
                                              Model             = Model,
                                              Backtest          = MLParameterList$BackTest,
                                              Debug             = MLParameterList$Debug,
                                              LoadModel         = MLParameterList$SaveModelToFile,
                                              FileName          = MLParameterList$FileNameOfModel,
                                              PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                                PredictVariable     = MLParameterList$PredictionVariable,
                                                Backtest            = MLParameterList$BackTest,
                                                Debug               = MLParameterList$Debug,
                                                TestingSet          = FALSE,
                                                RegressionModel     = MLParameterList$RegressionModel,
                                                Variable            = MLParameterList$PredictionVariable,
                                                RegType             = MLParameterList$RegressionType,
                                                DrawCharts          = MLParameterList$DrawChartsOfResults,
                                                Rescale=MLParameterList$Rescale,
                                                MaxValues=MLParameterList$Maximums,
                                                MinValues=MLParameterList$Minimums,
                                                ColumnNames=MLParameterList$DisplayColumnNames)
        
        # Predict testing set
        TestingPredictions <- PredictXGBoost(ListOfDataFrames[[2]],
                                             ColumnNames       = MLParameterList$VariableNames,
                                             Model             = Model,
                                             Backtest          = MLParameterList$BackTest,
                                             Debug             = MLParameterList$Debug,
                                             LoadModel         = MLParameterList$SaveModelToFile,
                                             FileName          = MLParameterList$FileNameOfModel,
                                             PredictVariable = MLParameterList$PredictionVariable)
        
        # Do results processing
        TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                               PredictVariable     = MLParameterList$PredictionVariable,
                                               Backtest            = MLParameterList$BackTest,
                                               Debug               = MLParameterList$Debug,
                                               TestingSet          = TRUE,
                                               RegressionModel     = MLParameterList$RegressionModel,
                                               Variable            = MLParameterList$PredictionVariable,
                                               RegType             = MLParameterList$RegressionType,
                                               DrawCharts          = MLParameterList$DrawChartsOfResults,
                                               Rescale=MLParameterList$Rescale,
                                               MaxValues=MLParameterList$Maximums,
                                               MinValues=MLParameterList$Minimums,
                                               ColumnNames=MLParameterList$DisplayColumnNames)
        
        Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
      }
      
    } else {
      
      print("Not enough data found < 1000 rows")
      Results <- NA
      
    }
  } else {
    print("No data found")
    Results <- NA
  }
  
  return(Results)
  
}


###############################################################################
#
#   Prediction Function
#
###############################################################################

MLPrediction <- function(MLParameterList,DataLoadParameters)
{
  
  # Load data
  DataFrame <- DataLoadAndFormat(Backtest   =  MLParameterList$BackTest,
                                 Debug      =  MLParameterList$Debug,
                                 ConvertToFactors = MLParameterList$ConvertToFactors,
                                 DataLoadParameters = DataLoadParameters)
  
  if (nrow(DataFrame)>0) 
  {
    
    # Pre-Process
    ListOfDataFrames <- PreProcess(DataFrame,
                                   Columns = MLParameterList$ColumnsToSelectForTraining,
                                   ColumnNames = MLParameterList$DisplayColumnNames,
                                   Backtest = MLParameterList$BackTest,
                                   Debug = MLParameterList$Debug,
                                   PercentageToSplit = MLParameterList$SplitPercent,
                                   UseSampleMethod = MLParameterList$SamplingMethod,
                                   OneHotEncodeFactors=MLParameterList$OneHotEncodeFactors,
                                   Rescale=MLParameterList$Rescale,
                                   MaxValues=MLParameterList$Maximums,
                                   MinValues=MLParameterList$Minimums)
    
    if (MLParameterList$RegressionModel == "SVM")
    {
      print("Predicting with a Support Vector Machine")
      
      # Predict testing set
      TestingPredictions <- PredictSVM(ListOfDataFrames[[2]],
                                       ColumnNames = MLParameterList$VariableNames,
                                       Model       = Model,
                                       Backtest    = MLParameterList$BackTest,
                                       Debug       = MLParameterList$Debug,
                                       LoadModel   = MLParameterList$SaveModelToFile,
                                       FileName    = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    if (MLParameterList$RegressionModel == "RF")
    {
      
      print("Prediction with Random Forrest - Original version")
      
      # Predict testing set
      TestingPredictions <- PredictRF(ListOfDataFrames[[2]],
                                      ColumnNames            = MLParameterList$VariableNames,
                                      Model                  = Model,
                                      Backtest               = FALSE,
                                      Debug                  = FALSE,
                                      LoadModel              = TRUE,
                                      FileName               = MLParameterList$FileNameOfModel)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = FALSE,
                                             Debug               = FALSE,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
    }
    
    if (MLParameterList$RegressionModel == "RFRLT")
    {
      print("Predicting with Random Forrest - RLT version")
      
      
      # Predict testing set
      TestingPredictions <- PredictRFRLT(ListOfDataFrames[[2]],
                                         ColumnNames       = MLParameterList$VariableNames,
                                         Model             = Model,
                                         Backtest          = MLParameterList$BackTest,
                                         Debug             = MLParameterList$Debug,
                                         LoadModel         = MLParameterList$SaveModelToFile,
                                         FileName          = MLParameterList$FileNameOfModel,
                                         PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    # Use XGBoost model to train and predict
    if (MLParameterList$RegressionModel == "XGB")
    {
      print("Predicting with XGBoost")
      
      
      # Predict testing set
      TestingPredictions <- PredictXGBoost(ListOfDataFrames[[2]],
                                           ColumnNames       = MLParameterList$VariableNames,
                                           Model             = Model,
                                           Backtest          = MLParameterList$BackTest,
                                           Debug             = MLParameterList$Debug,
                                           LoadModel         = MLParameterList$SaveModelToFile,
                                           FileName          = MLParameterList$FileNameOfModel,
                                           PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
    }
    
    # Use KNN model to train and predict
    if (MLParameterList$RegressionModel == "KNN")
    {
      print("Training with K nearest neighbour")
      
      # Predict testing set
      TestingPredictions <- PredictKNN(ListOfDataFrames[[2]],
                                       ColumnNames       = MLParameterList$VariableNames,
                                       Model             = Model,
                                       Backtest          = MLParameterList$BackTest,
                                       Debug             = MLParameterList$Debug,
                                       LoadModel         = MLParameterList$SaveModelToFile,
                                       FileName          = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    if (MLParameterList$RegressionModel == "NN")
    {
      
      print("Training with Neural Network version")
      
      # Predict training set
      TestingPredictions <- PredictNN(DataFrame=ListOfDataFrames[[2]],
                                      PredictVariable =  MLParameterList$PredictionVariable,
                                      ColumnNames     =  MLParameterList$DisplayColumnNames,
                                      Model,
                                      Backtest        =  MLParameterList$BackTest,
                                      Debug           =  MLParameterList$Debug,
                                      LoadModel       =  MLParameterList$SaveModelToFile,
                                      FileName        =  MLParameterList$FileNameOfModel)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    if (MLParameterList$RegressionModel == "DEEPNET")
    {
      
      print("Training with DEEPNET")
      
      # Predict testing set
      TestingPredictions <- PredictDeepNet(ListOfDataFrames[[2]],
                                           ColumnNames            = MLParameterList$VariableNames,
                                           Model                  = Model,
                                           Backtest               = MLParameterList$BackTest,
                                           Debug                  = MLParameterList$Debug,
                                           LoadModel              = MLParameterList$SaveModelToFile,
                                           FileName               = MLParameterList$FileNameOfModel,
                                           PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
  } else {
    print("No data found")
    TestingResultsDataFrame <- NA
  }
  
  return(TestingResultsDataFrame)
  
}


############################################################################
#
#
############################################################################

# Call these two functions when script is sourced
DataLoadParameters <- SetDataLoadParameters()
MLParameterList    <- SetParameters()

# Data analysis function
#DataLoadParameters$Instrument <- "LLOY.UK"
#MLParameterList$PrintExamplesinAnalysis   <- TRUE
#MLParameterList$DrawChartsinAnalysis      <- TRUE
#MLDataAnalysis(MLParameterList,DataLoadParameters)


# Call the training function
#Results <- MLTraining(MLParameterList,DataLoadParameters)

# Auto ML - Which model gives best predictions
AutoML <- function()
{
  ModelsToTest <- c("RF","NN","KNN","XGB","DEEPNET","RFRLT","SVM")
  ListOfResults <- data.frame(Model = "NA",RMS = 0)
  for (Model in ModelsToTest)
  {
    MLParameterList$RegressionModel           <- Model 
    Results <- MLTraining(MLParameterList,DataLoadParameters)
    ListOfResults <- rbind(ListOfResults,data.frame(Model=Model,RMS=sqrt(mean(Results$Error * Results$Error))))
  }
  ListOfResults <- ListOfResults[-1,]
  ListOfResults$RMS <- round(ListOfResults$RMS,5)
  library(plyr)
  ListOfResults <- arrange(ListOfResults,RMS)
  print(ListOfResults)
}

#AutoML()


#Results <- MLPrediction(MLParameterList,DataLoadParameters)
#print(head(Results))

# Get the FTSE index
#GetIndexElements <- function(x,date="") {
#  
#  # Set the date equal to today
#  date <- format(Sys.time(), "%Y%m%d")
#  
#  # Now get the index data from the ResearchDB Cloud
#  url <- paste("http://uklon-hft002:8081/ResearchDb/IndexMembers?date=",date,sep="")
#  
#  Index <- read.csv(url)
#  Index <- Index$Instrument.Code
#  
#  # Return the value for the field requested
#  return(Index)
#}

ScannerFunction <- function()
{
  #Instruments <- GetIndexElements("","20170807")
  
  # Opportunity Scanner
  DataLoadParameters$SDMultiplier           <- 1.69   #1.6    # n times SD - Set low so we find some
  MLParameterList$SplitPercent              <- 80/100    # Use most of the data for training
  MLParameterList$DrawChartsOfResults       <- FALSE     # Dont draw all the charts
  DataLoadParameters$TradingTimeFrameInDays <- 114  # Days
  MLParameterList$RegressionModel           <- "KNN" # Use KNN or RFRLT or RF
  MLParameterList$K <- 48
  Instruments <- c("AAPL.US","TSLA.US","GLEN.UK","AAL.UK",
                   "BRBY.UK","CWK.UK","CAT.US","MKS.UK",
                   "ES.F","X.F","DY.F","NY.F","RJ.F","MX.F","GC.F","SI.F","PA.F","PL.F")  # ,"GC.F" Gold
                    # ES = US500, NY = N225, RJ = Russel 2000, DY = DAX, MX = CAC40
  ListOfResults <- NULL
  ListOfPredictions <- NULL
  i <- 0
  for (Instrument in Instruments)
  {
    i <- i + 1
    print(paste("Working on instrument ... ",Instrument))
    DataLoadParameters$Instrument <- Instrument
    Results <- MLTraining(MLParameterList,DataLoadParameters)
    if (is.na(Results) == FALSE)
    {
      ThisDate <- Results$Date[nrow(Results)]
      ListOfResults <- rbind(ListOfResults,data.frame(Instrument=Instrument,
                                                      Date=ThisDate,
                                                      Close=Results$Close_Price[nrow(Results)],
                                                      BuyPred=Results$BuyPrediction[nrow(Results)],
                                                      SellPred = Results$SellPrediction[nrow(Results)],
                                                      Prediction = Results$Prediction[nrow(Results)],
                                                      Profit = Results$Profit[nrow(Results)]))
      PredDF <- data.frame(Pred=Results$Prediction,
                           Date=Results$Date,
                           Close=Results$Close_Price)
      colnames(PredDF) <- c(Instrument,"Date",paste(Instrument,"Close",sep="."))
      rownames(PredDF) <- Results$Date
      ListOfPredictions[[i]] <- PredDF
      write.csv(ListOfResults,"d:\\dropbox\\dropbox\\pdfs\\charts\\ScannerResults.csv")
      
    }
  }
  ListOfResults <- ListOfResults[-1,]
  library(plyr)
  ListOfResults <- arrange(ListOfResults,BuyPred)
  print(ListOfResults)
  print(paste("Average Prediction",mean(ListOfResults$Prediction)))
  print(paste("Average Profit",mean(ListOfResults$Profit,na.rm = TRUE)))
  
  # Separate the index futures
  library(stringr)
  library(dplyr)
  
  IndexFuturesList <- ListOfResults %>%
    filter(str_detect(Instrument, ".F")) %>% 
    head(6)
  
  print(IndexFuturesList)
  print(paste("Average Index Futures Prediction",mean(IndexFuturesList$Prediction)))
  
  return(ListOfPredictions)
  
}

Predictions <- ScannerFunction()

df <- NULL
i <- 0
for (Prediction in Predictions)
{
  i <- i + 1
  NewDF <- Predictions[[i]]
  if (i==1) {
    df <- NewDF
  } else {
    df <- merge(df,NewDF,by="Date")
  }
}

write.csv(df,"d:\\dropbox\\dropbox\\pdfs\\charts\\Predictions.csv")

#shell("dropbox.bat")

